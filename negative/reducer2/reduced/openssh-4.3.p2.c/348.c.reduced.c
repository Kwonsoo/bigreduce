/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */
typedef unsigned int size_t;
typedef unsigned char __u_char;
typedef unsigned int __u_int;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef long __time_t;
typedef __u_char u_char;
typedef __u_int u_int;
typedef __time_t time_t;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct __anonstruct_Buffer_70 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
typedef struct __anonstruct_Buffer_70 Buffer;
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
struct Authctxt;
struct Authctxt;
typedef struct Authctxt Authctxt;
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   Buffer *loginmsg ;
   void *methoddata ;
};
typedef unsigned int __uint32_t;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned long __ino_t;
typedef __u_quad_t __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef __quad_t __blkcnt64_t;
typedef int __ssize_t;
typedef unsigned int __socklen_t;
typedef __off64_t off_t;
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef int int32_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
typedef __socklen_t socklen_t;
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
struct exit_status {
   short e_termination ;
   short e_exit ;
};
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(__uint32_t )] ;
};
struct sockaddr_in;
struct sockaddr_in;
struct sockaddr_in6;
struct sockaddr_in6;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
union __anonunion_in6_u_62 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion_in6_u_62 in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[128] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
typedef struct stack_st STACK;
struct bignum_st;
struct bignum_st;
typedef struct bignum_st BIGNUM;
struct bignum_ctx;
struct bignum_ctx;
typedef struct bignum_ctx BN_CTX;
struct bn_blinding_st;
struct bn_blinding_st;
typedef struct bn_blinding_st BN_BLINDING;
struct bn_mont_ctx_st;
struct bn_mont_ctx_st;
typedef struct bn_mont_ctx_st BN_MONT_CTX;
struct bn_gencb_st;
struct bn_gencb_st;
typedef struct bn_gencb_st BN_GENCB;
struct env_md_st;
struct env_md_st;
typedef struct env_md_st EVP_MD;
struct env_md_ctx_st;
struct env_md_ctx_st;
typedef struct env_md_ctx_st EVP_MD_CTX;
struct dh_st;
struct dh_st;
typedef struct dh_st DH;
struct dh_method;
struct dh_method;
typedef struct dh_method DH_METHOD;
struct dsa_st;
struct dsa_st;
typedef struct dsa_st DSA;
struct dsa_method;
struct dsa_method;
typedef struct dsa_method DSA_METHOD;
struct rsa_st;
struct rsa_st;
typedef struct rsa_st RSA;
struct rsa_meth_st;
struct rsa_meth_st;
typedef struct rsa_meth_st RSA_METHOD;
struct engine_st;
struct engine_st;
typedef struct engine_st ENGINE;
struct crypto_ex_data_st;
struct crypto_ex_data_st;
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
union __anonunion_cb_72 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_72 cb ;
};
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
typedef struct DSA_SIG_st DSA_SIG;
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
struct Key;
struct Key;
typedef struct Key Key;
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
struct Cipher;
struct Cipher;
typedef struct Cipher Cipher;
struct Kex;
struct Kex;
typedef struct Kex Kex;
struct Mac;
struct Mac;
typedef struct Mac Mac;
struct Comp;
struct Comp;
typedef struct Comp Comp;
struct Enc;
struct Enc;
typedef struct Enc Enc;
struct Newkeys;
struct Newkeys;
typedef struct Newkeys Newkeys;
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD const   *md ;
   u_int mac_len ;
   u_char *key ;
   u_int key_len ;
};
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   u_int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   EVP_MD const   *evp_md ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[3])(Kex * ) ;
};
typedef unsigned long __u_long;
typedef __u_long u_long;
typedef unsigned int u_int32_t;
typedef unsigned long u_int64_t;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
struct internal_state;
struct internal_state;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
struct internal_state {
   int dummy ;
};
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_AUDIT_EVENT = 56,
    MONITOR_REQ_AUDIT_COMMAND = 57,
    MONITOR_REQ_TERM = 58
} ;
struct mm_master;
struct mm_master;
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
struct Session;
struct Session;
struct __anonstruct_env_79 {
   char *name ;
   char *val ;
};
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int *x11_chanids ;
   int is_subsystem ;
   u_int num_env ;
   struct __anonstruct_env_79 *env ;
};
typedef unsigned short __u_short;
typedef __u_short u_short;
typedef __uid_t uid_t;
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef void (*mysig_t)(int  );
typedef struct Session Session;
enum __anonenum_SyslogFacility_77 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11,
    SYSLOG_FACILITY_NOT_SET = -1
} ;
typedef enum __anonenum_SyslogFacility_77 SyslogFacility;
enum __anonenum_LogLevel_78 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
typedef enum __anonenum_LogLevel_78 LogLevel;
struct __anonstruct_ServerOptions_79 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   int address_family ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   u_int num_accept_env ;
   char *accept_env[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   int max_authtries ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int use_pam ;
   int permit_tun ;
};
typedef struct __anonstruct_ServerOptions_79 ServerOptions;
struct mon_table;
struct mon_table;
struct mm_share;
struct __anonstruct_next_80 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
struct mm_share {
   struct __anonstruct_next_80 next ;
   void *address ;
   size_t size ;
};
struct mmtree {
   struct mm_share *rbh_root ;
};
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
struct __anonstruct_child_state_81 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
typedef long __off_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
struct Authmethod;
struct Authmethod;
typedef struct Authmethod Authmethod;
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
enum __anonenum_HostStatus_77 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
typedef enum __anonenum_HostStatus_77 HostStatus;
typedef __gid_t gid_t;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct KbdintDevice;
struct KbdintDevice;
typedef struct KbdintDevice KbdintDevice;
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
typedef void dispatch_fn(int  , u_int32_t  , void * );
struct KbdintAuthctxt;
struct KbdintAuthctxt;
typedef struct KbdintAuthctxt KbdintAuthctxt;
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
struct sockaddr_un;
struct sockaddr_un;
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
struct Channel;
struct Channel;
typedef struct Channel Channel;
typedef void channel_callback_fn(int  , void * );
typedef int channel_infilter_fn(struct Channel * , char * , int  );
typedef u_char *channel_outfilter_fn(struct Channel * , u_char ** , u_int * );
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int ctl_fd ;
   int isatty ;
   int wfd_isatty ;
   int client_tty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   void *confirm_ctx ;
   channel_callback_fn *detach_user ;
   int detach_close ;
   channel_infilter_fn *input_filter ;
   channel_outfilter_fn *output_filter ;
   int datagram ;
};
struct envstring {
   struct envstring *next ;
   char *s ;
};
union __anonunion___u_80 {
   int __in ;
   int __i ;
};
union __anonunion___u_81 {
   int __in ;
   int __i ;
};
union __anonunion___u_82___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_83___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_84___0 {
   int __in ;
   int __i ;
};
struct AuthMethod1 {
   int type ;
   char *name ;
   int *enabled ;
   int (*method)(Authctxt * , char * , size_t  ) ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef int __sig_atomic_t;
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_8 __sigset_t;
typedef __sigset_t sigset_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_9 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_9 fd_set;
typedef __sig_atomic_t sig_atomic_t;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
union __anonunion___u_81___0 {
   int __in ;
   int __i ;
};
union __anonunion___u_82___1 {
   int __in ;
   int __i ;
};
union __anonunion___u_83___1 {
   int __in ;
   int __i ;
};
union __anonunion___u_84___1 {
   int __in ;
   int __i ;
};
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
enum __anonenum_ServerOpCodes_78 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sAddressFamily = 21,
    sPrintMotd = 22,
    sPrintLastLog = 23,
    sIgnoreRhosts = 24,
    sX11Forwarding = 25,
    sX11DisplayOffset = 26,
    sX11UseLocalhost = 27,
    sStrictModes = 28,
    sEmptyPasswd = 29,
    sTCPKeepAlive = 30,
    sPermitUserEnvironment = 31,
    sUseLogin = 32,
    sAllowTcpForwarding = 33,
    sCompression = 34,
    sAllowUsers = 35,
    sDenyUsers = 36,
    sAllowGroups = 37,
    sDenyGroups = 38,
    sIgnoreUserKnownHosts = 39,
    sCiphers = 40,
    sMacs = 41,
    sProtocol = 42,
    sPidFile = 43,
    sGatewayPorts = 44,
    sPubkeyAuthentication = 45,
    sXAuthLocation = 46,
    sSubsystem = 47,
    sMaxStartups = 48,
    sMaxAuthTries = 49,
    sBanner = 50,
    sUseDNS = 51,
    sHostbasedAuthentication = 52,
    sHostbasedUsesNameFromPacketOnly = 53,
    sClientAliveInterval = 54,
    sClientAliveCountMax = 55,
    sAuthorizedKeysFile = 56,
    sAuthorizedKeysFile2 = 57,
    sGssAuthentication = 58,
    sGssCleanupCreds = 59,
    sAcceptEnv = 60,
    sPermitTunnel = 61,
    sUsePrivilegeSeparation = 62,
    sDeprecated = 63,
    sUnsupported = 64
} ;
typedef enum __anonenum_ServerOpCodes_78 ServerOpCodes;
struct __anonstruct_keywords_79 {
   char const   *name ;
   ServerOpCodes opcode ;
};
typedef __mode_t mode_t;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
typedef struct MD5state_st MD5_CTX;
typedef unsigned char u_int8_t;
typedef __fd_mask fd_mask;
struct __anonstruct_sensitive_data_82 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
 ;
 ;
 ;
extern void buffer_append(Buffer * , void const   * , u_int  ) ;
 ;
 ;
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
extern void error(char const   *  , ...) ;
extern void logit(char const   *  , ...) ;
extern void debug3(char const   *  , ...) ;
Buffer loginmsg  ;
 
;
int auth_shadow_pwexpired(Authctxt *ctxt ) 
;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
  ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
 ;
 ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
 ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
 ;
extern struct passwd *getpwnam(char const   *__name ) ;
  ;
extern int close(int __fd ) ;
 ;
 ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
extern void *xmalloc(size_t  ) ;
extern void xfree(void * ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) ;
extern  __attribute__((__noreturn__)) void fatal(char const   *  , ...) ;
extern void debug(char const   *  , ...) ;
 ;
 ;
extern int packet_connection_is_on_socket(void) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) 
;
 ;
 ;
extern BIGNUM *BN_new(void) ;
extern void BN_clear_free(BIGNUM *a ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
void kexgex_server(Kex *kex ) ;
 ;
extern void packet_start(u_char  ) ;
 ;
 ;
extern void packet_send(void) ;
extern int packet_read(void) ;
extern void packet_read_expect(int type ) ;
extern u_int packet_get_int(void) ;
 ;
extern void packet_disconnect(char const   *fmt  , ...) ;
extern void packet_write_wait(void) ;
extern int packet_remaining(void) ;
 ;
 ;
 ;
int use_privsep  ;
 ;
 ;
void kexgex_server(Kex *kex ) 
;
void kexdh_server(Kex *kex ) ;
 ;
 ;
 ;
void kexdh_server(Kex *kex ) 
;
extern void buffer_init(Buffer * ) ;
 ;
extern void buffer_free(Buffer * ) ;
 ;
 ;
 ;
 ;
 ;
char *forced_command ;
 ;
 ;
 ;
extern u_int buffer_get_int(Buffer * ) ;
 ;
 ;
extern int buffer_get_char(Buffer * ) ;
 ;
extern void *buffer_get_string(Buffer * , u_int * ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
 ;
 ;
 ;
 ;
 ;
struct passwd *mm_getpwnamallow(char const   *username ) ;
 ;
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
void mm_terminate(void) ;
 ;
 ;
void mm_ssh1_session_id(u_char *session_id___0 ) ;
int mm_ssh1_session_key(BIGNUM *num ) ;
 ;
 ;
void mm_send_keystate(struct monitor *monitor ) ;
 ;
 ;
extern char *xstrdup(char const   * ) ;
 ;
extern int compat20 ;
extern Newkeys *newkeys[] ;
extern z_stream incoming_stream ;
extern z_stream outgoing_stream ;
struct monitor *pmonitor ;
extern Buffer input ;
extern Buffer output ;
 
;
 
;
 
;
 
;
 
;
 
;
struct passwd *mm_getpwnamallow(char const   *username ) 
;
 
;
 
;
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
void mm_send_keystate(struct monitor *monitor ) 
;
 
;
 
;
void mm_terminate(void) 
;
int mm_ssh1_session_key(BIGNUM *num ) 
;
 
;
 
;
 
;
void mm_ssh1_session_id(u_char *session_id___0 ) 
;
 
;
 
;
 
;
 ;
 ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
 ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
 ;
extern void setproctitle(char const   *fmt  , ...) ;
extern mysig_t mysignal(int sig , void (*act)(int  ) ) ;
 ;
extern void key_free(Key * ) ;
 ;
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
 ;
 ;
 ;
 ;
 ;
 ;
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
int auth_root_allowed(char *method ) ;
 ;
struct passwd *getpwnamallow(char const   *user ) ;
 ;
Key *get_hostkey_by_type(int type ) ;
int get_hostkey_index(Key *key ) ;
int ssh1_session_key(BIGNUM *session_key_int ) ;
struct passwd *fakepw(void) ;
extern void packet_set_encryption_key(u_char const   * , u_int  , int  ) ;
extern void packet_set_protocol_flags(u_int  ) ;
 ;
 ;
 ;
 ;
int no_pty_flag ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
extern int datafellows ;
ServerOptions options  ;
u_int utmp_len ;
extern Newkeys *current_keys[] ;
u_char session_id[16]  ;
Buffer auth_debug  ;
int auth_debug_init  ;
struct __anonstruct_child_state_81 child_state  ;
int mm_answer_moduli(int sock , Buffer *m ) ;
int mm_answer_sign(int sock , Buffer *m ) ;
int mm_answer_pwnamallow(int sock , Buffer *m ) ;
int mm_answer_auth2_read_banner(int sock , Buffer *m ) ;
int mm_answer_authserv(int sock , Buffer *m ) ;
int mm_answer_authpassword(int sock , Buffer *m ) ;
int mm_answer_keyallowed(int sock , Buffer *m ) ;
int mm_answer_keyverify(int sock , Buffer *m ) ;
int mm_answer_pty(int sock , Buffer *m ) ;
int mm_answer_pty_cleanup(int sock , Buffer *m ) ;
int mm_answer_term(int sock , Buffer *req ) ;
int mm_answer_rsa_keyallowed(int sock , Buffer *m ) ;
int mm_answer_rsa_challenge(int sock , Buffer *m ) ;
int mm_answer_rsa_response(int sock , Buffer *m ) ;
int mm_answer_sesskey(int sock , Buffer *m ) ;
int mm_answer_sessid(int sock , Buffer *m ) ;
static Authctxt *authctxt  ;
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
static u_char *key_blob  =    (u_char *)((void *)0);
static u_int key_bloblen  =    (u_int )0;
static int key_blobtype  =    0;
static char *hostbased_cuser  =    (char *)((void *)0);
static char *hostbased_chost  =    (char *)((void *)0);
static char *auth_method  =    (char *)"unknown";
static u_int session_id2_len___0  =    (u_int )0;
static u_char *session_id2___0  =    (u_char *)((void *)0);
static pid_t monitor_child_pid  ;
struct mon_table mon_dispatch_proto20[9]  = 
  {      {(enum monitor_reqtype )0, 16, & mm_answer_moduli}, 
        {(enum monitor_reqtype )4, 16, & mm_answer_sign}, 
        {(enum monitor_reqtype )6, 16, & mm_answer_pwnamallow}, 
        {(enum monitor_reqtype )3, 16, & mm_answer_authserv}, 
        {(enum monitor_reqtype )8, 16, & mm_answer_auth2_read_banner}, 
        {(enum monitor_reqtype )10, 12, & mm_answer_authpassword}, 
        {(enum monitor_reqtype )20, 4, & mm_answer_keyallowed}, 
        {(enum monitor_reqtype )22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
struct mon_table mon_dispatch_postauth20[6]  = {      {(enum monitor_reqtype )0, 0, & mm_answer_moduli}, 
        {(enum monitor_reqtype )4, 0, & mm_answer_sign}, 
        {(enum monitor_reqtype )25, 0, & mm_answer_pty}, 
        {(enum monitor_reqtype )27, 0, & mm_answer_pty_cleanup}, 
        {(enum monitor_reqtype )58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
struct mon_table mon_dispatch_proto15[9]  = 
  {      {(enum monitor_reqtype )6, 16, & mm_answer_pwnamallow}, 
        {(enum monitor_reqtype )28, 16, & mm_answer_sesskey}, 
        {(enum monitor_reqtype )30, 16, & mm_answer_sessid}, 
        {(enum monitor_reqtype )10, 12, & mm_answer_authpassword}, 
        {(enum monitor_reqtype )31, 4, & mm_answer_rsa_keyallowed}, 
        {(enum monitor_reqtype )20, 4, & mm_answer_keyallowed}, 
        {(enum monitor_reqtype )33, 16, & mm_answer_rsa_challenge}, 
        {(enum monitor_reqtype )35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
struct mon_table mon_dispatch_postauth15[4]  = {      {(enum monitor_reqtype )25, 16, & mm_answer_pty}, 
        {(enum monitor_reqtype )27, 16, & mm_answer_pty_cleanup}, 
        {(enum monitor_reqtype )58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
struct mon_table *mon_dispatch  ;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
int mm_answer_moduli(int sock , Buffer *m ) 
;
int mm_answer_sign(int sock , Buffer *m ) 
;
int mm_answer_pwnamallow(int sock , Buffer *m ) 
;
int mm_answer_auth2_read_banner(int sock , Buffer *m ) 
;
int mm_answer_authserv(int sock , Buffer *m ) 
;
static int call_count  ;
int mm_answer_authpassword(int sock , Buffer *m ) 
;
 
;
int mm_answer_keyallowed(int sock , Buffer *m ) 
;
 
;
 
;
int mm_answer_keyverify(int sock , Buffer *m ) 
;
 
;
 
;
int mm_answer_pty(int sock , Buffer *m ) 
;
int mm_answer_pty_cleanup(int sock , Buffer *m ) 
;
int mm_answer_sesskey(int sock , Buffer *m ) 
;
int mm_answer_sessid(int sock , Buffer *m ) 
;
int mm_answer_rsa_keyallowed(int sock , Buffer *m ) 
;
int mm_answer_rsa_challenge(int sock , Buffer *m ) 
;
int mm_answer_rsa_response(int sock , Buffer *m ) 
;
int mm_answer_term(int sock , Buffer *req ) 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
extern u_int packet_get_char(void) ;
extern void *packet_get_string(u_int *length_ptr ) ;
extern void verbose(char const   *  , ...) ;
 ;
 ;
 ;
extern char const   *key_type(Key const   * ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
u_char *session_id2 ;
u_int session_id2_len ;
static int userauth_pubkey(Authctxt *authctxt___0 ) 
;
 
;
 
;
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
static int userauth_passwd(Authctxt *authctxt___0 ) 
;
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
 ;
 ;
static int none_enabled  =    1;
 
;
 
;
 
;
static int userauth_none(Authctxt *authctxt___0 ) 
;
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
 ;
static int userauth_kbdint(Authctxt *authctxt___0 ) 
;
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
 ;
 ;
 ;
extern char const   *get_canonical_hostname(int  ) ;
extern char const   *get_remote_ipaddr(void) ;
static int userauth_hostbased(Authctxt *authctxt___0 ) 
;
 
;
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
 ;
 ;
 ;
 ;
 ;
 ;
 ;
static int ngroups  ;
static char **groups_byname  ;
 
;
 
;
 
;
 ;
 ;
 ;
 ;
extern void packet_put_char(int ch ) ;
extern void packet_put_int(u_int value ) ;
 ;
 ;
 ;
 ;
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 ;
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
static KbdintDevice *device  ;
 
;
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
;
void abandon_challenge_response(Authctxt *authctxt___0 ) 
;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
 ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
 ;
 ;
 ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
 ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
 ;
 ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
extern char **environ ;
 ;
 ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
 ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
 ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
extern int compat13 ;
int no_port_forwarding_flag ;
int no_agent_forwarding_flag ;
int no_x11_forwarding_flag ;
struct envstring *custom_environment ;
extern void log_init(char * , LogLevel  , SyslogFacility  , int  ) ;
 ;
 ;
 ;
 ;
extern int get_remote_port(void) ;
 ;
void do_authenticated(Authctxt *authctxt___0 ) ;
void do_cleanup(Authctxt *authctxt___0 ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
extern char *__progname ;
int log_stderr ;
int debug_flag ;
void destroy_sensitive_data(void) ;
char const   *original_command  =    (char const   *)((void *)0);
Session sessions[10]  ;
static int is_child  =    0;
static char *auth_sock_name  =    (char *)((void *)0);
static char *auth_sock_dir  =    (char *)((void *)0);
 
;
 
;
 
;
void do_authenticated(Authctxt *authctxt___0 ) 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
static int did_init  =    0;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 ;
static int called  =    0;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
static char buf[1024]  ;
 
;
 
;
 
;
 
;
static int called___0  =    0;
void do_cleanup(Authctxt *authctxt___0 ) 
;
 ;
 ;
 ;
 ;
int forced_tun_device ;
extern int a2port(char const   * ) ;
 ;
 ;
 ;
 ;
 ;
 ;
int no_port_forwarding_flag  =    0;
int no_agent_forwarding_flag  =    0;
int no_x11_forwarding_flag  =    0;
int no_pty_flag  =    0;
char *forced_command  =    (char *)((void *)0);
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
int forced_tun_device  =    -1;
 
;
 
;
void do_authentication2(Authctxt *authctxt___0 ) ;
 ;
extern void dispatch_run(int  , int * , void * ) ;
 ;
 ;
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
 ;
 ;
 ;
 ;
void do_authentication2(Authctxt *authctxt___0 ) 
;
 
;
 
;
 
;
 
;
 
;
extern int BN_num_bits(BIGNUM const   *a ) ;
extern void packet_get_bignum(BIGNUM *value ) ;
 ;
 ;
void do_authentication(Authctxt *authctxt___0 ) ;
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
static char *client_user  =    (char *)((void *)0);
struct AuthMethod1  const  auth1_methods[6]  = {      {9, (char *)"password", & options.password_authentication, & auth1_process_password}, 
        {6,
      (char *)"rsa", & options.rsa_authentication, & auth1_process_rsa}, 
        {35, (char *)"rhosts-rsa", & options.rhosts_rsa_authentication, & auth1_process_rhosts_rsa}, 
        {39,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_challenge}, 
        {41,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_response}, 
        {-1,
      (char *)((void *)0), (int *)((void *)0), (int (*)(Authctxt * , char * , size_t  ))((void *)0)}};
static struct AuthMethod1  const  *lookup_authmethod1(int type ) 
;
static char buf___0[64]  ;
static char *get_authname(int type ) 
;
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) 
;
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
;
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
;
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) 
;
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  int authenticated ;
  char *response ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  {
  {
  authenticated = 0;
  tmp = packet_get_string(& dlen);
  response = (char *)tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = packet_remaining();
    _len = tmp___0;
    }
    if (_len > 0) {
      {
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            204);
      packet_disconnect("Packet integrity error.");
      }
    }
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  authenticated = verify_response(authctxt___0, (char const   *)response);
  memset((void *)response, 'r', dlen);
  xfree((void *)response);
  }
  return (authenticated);
}
}
static void do_authloop(Authctxt *authctxt___0 ) 
{ 
  int authenticated ;
  char info[1024] ;
  int prev ;
  int type ;
  struct AuthMethod1  const  *meth ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  {
  authenticated = 0;
  prev = 0;
  type = 0;
  if (authctxt___0->valid) {
    tmp = "";
  } else {
    tmp = "invalid user ";
  }
  {
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
  }
  if (options.password_authentication) {
    if (use_privsep) {
      {
      tmp___0 = mm_auth_password(authctxt___0, (char *)"");
      tmp___2 = tmp___0;
      }
    } else {
      {
      tmp___1 = auth_password(authctxt___0, "");
      tmp___2 = tmp___1;
      }
    }
    if (tmp___2) {
      {
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
      }
      return;
    }
  }
  {
  packet_start((u_char )15);
  packet_send();
  packet_write_wait();
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    authenticated = 0;
    info[0] = (char )'\000';
    prev = type;
    type = packet_read();
    }
    if (prev == 39) {
      if (type != 41) {
        {
        abandon_challenge_response(authctxt___0);
        }
      }
    }
    {
    meth = lookup_authmethod1(type);
    }
    if ((unsigned long )meth == (unsigned long )((void *)0)) {
      {
      logit("Unknown message during authentication: type %d", type);
      }
      goto skip;
    }
    if (! *(meth->enabled)) {
      {
      verbose("%s authentication disabled.", meth->name);
      }
      goto skip;
    }
    {
    authenticated = (*(meth->method))(authctxt___0, info, (size_t )sizeof(info));
    }
    if (authenticated == -1) {
      goto __Cont;
    }
    if (! authctxt___0->valid) {
      if (authenticated) {
        {
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
        }
      }
    }
    if (authenticated) {
      if ((authctxt___0->pw)->pw_uid == 0U) {
        {
        tmp___3 = auth_root_allowed((char *)meth->name);
        }
        if (! tmp___3) {
          authenticated = 0;
        }
      }
    }
    skip: 
    {
    tmp___4 = get_authname(type);
    auth_log(authctxt___0, authenticated, tmp___4, info);
    }
    if ((unsigned long )client_user != (unsigned long )((void *)0)) {
      {
      xfree((void *)client_user);
      client_user = (char *)((void *)0);
      }
    }
    if (authenticated) {
      return;
    }
    tmp___5 = authctxt___0->failures;
    (authctxt___0->failures) ++;
    if (tmp___5 > options.max_authtries) {
      {
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
      }
    }
    {
    packet_start((u_char )15);
    packet_send();
    packet_write_wait();
    }
    __Cont: ;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
void do_authentication(Authctxt *authctxt___0 ) 
{ 
  u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  struct passwd *tmp___2 ;
  struct passwd *tmp___3 ;
  struct passwd *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  {
  {
  style = (char *)((void *)0);
  packet_read_expect(4);
  tmp = packet_get_string(& ulen);
  user = (char *)tmp;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    {
    tmp___0 = packet_remaining();
    _len = tmp___0;
    }
    if (_len > 0) {
      {
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            380);
      packet_disconnect("Packet integrity error.");
      }
    }
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
  style = strchr((char const   *)user, ':');
  }
  if ((unsigned long )style != (unsigned long )((void *)0)) {
    tmp___1 = style;
    style ++;
    *tmp___1 = (char )'\000';
  }
  authctxt___0->user = user;
  authctxt___0->style = style;
  if (use_privsep) {
    {
    tmp___3 = mm_getpwnamallow((char const   *)user);
    tmp___2 = tmp___3;
    }
  } else {
    {
    tmp___4 = getpwnamallow((char const   *)user);
    tmp___2 = tmp___4;
    }
  }
  authctxt___0->pw = tmp___2;
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    authctxt___0->valid = 1;
  } else {
    {
    debug("do_authentication: invalid user %s", user);
    authctxt___0->pw = fakepw();
    }
  }
  if (use_privsep) {
    tmp___5 = " [net]";
  } else {
    tmp___5 = "";
  }
  if (authctxt___0->valid) {
    tmp___6 = (char const   *)user;
  } else {
    tmp___6 = "unknown";
  }
  {
  setproctitle("%s%s", tmp___6, tmp___5);
  }
  if (! use_privsep) {
    {
    tmp___7 = getuid();
    }
    if (tmp___7 != 0U) {
      if (authctxt___0->pw) {
        {
        tmp___8 = getuid();
        }
        if ((authctxt___0->pw)->pw_uid != tmp___8) {
          {
          packet_disconnect("Cannot change user when server not running as root.");
          }
        }
      }
    }
  }
  {
  do_authloop(authctxt___0);
  packet_start((u_char )14);
  packet_send();
  packet_write_wait();
  }
  return;
}
}
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;

void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ 
  void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  {
  authlog = & verbose;
  if (authenticated == 1) {
    authlog = & logit;
  } else
  if (! authctxt___0->valid) {
    authlog = & logit;
  } else
  if (authctxt___0->failures >= options.max_authtries / 2) {
    authlog = & logit;
  } else {
    {
    tmp = strcmp((char const   *)method, "password");
    }
    if (tmp == 0) {
      authlog = & logit;
    }
  }
  if (authctxt___0->postponed) {
    authmsg = (char *)"Postponed";
  } else
  if (authenticated) {
    authmsg = (char *)"Accepted";
  } else {
    authmsg = (char *)"Failed";
  }
  {
  tmp___0 = get_remote_port();
  tmp___1 = get_remote_ipaddr();
  }
  if (authctxt___0->valid) {
    tmp___2 = "";
  } else {
    tmp___2 = "invalid user ";
  }
  {
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___2,
             authctxt___0->user, tmp___1, tmp___0, info);
  }
  if (authenticated == 0) {
    if (! authctxt___0->postponed) {
      {
      tmp___4 = strcmp((char const   *)method, "password");
      }
      if (tmp___4 == 0) {
        {
        tmp___3 = get_canonical_hostname(options.use_dns);
        record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
        }
      } else {
        {
        tmp___5 = strncmp((char const   *)method, "keyboard-interactive", (size_t )20);
        }
        if (tmp___5 == 0) {
          {
          tmp___3 = get_canonical_hostname(options.use_dns);
          record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
          }
        } else {
          {
          tmp___6 = strcmp((char const   *)method, "challenge-response");
          }
          if (tmp___6 == 0) {
            {
            tmp___3 = get_canonical_hostname(options.use_dns);
            record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
            }
          }
        }
      }
    }
  }
  return;
}
}
int auth_root_allowed(char *method ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  {
  if (options.permit_root_login == 3) {
    goto case_3;
  }
  if (options.permit_root_login == 2) {
    goto case_2;
  }
  if (options.permit_root_login == 1) {
    goto case_1;
  }
  goto switch_break;
  case_3: 
  return (1);
  goto switch_break;
  case_2: 
  {
  tmp = strcmp((char const   *)method, "password");
  }
  if (tmp != 0) {
    return (1);
  }
  goto switch_break;
  case_1: 
  if (forced_command) {
    {
    logit("Root login accepted for forced command.");
    }
    return (1);
  }
  goto switch_break;
  switch_break: 
  {
  tmp___0 = get_remote_ipaddr();
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___0);
  }
  return (0);
}
}
 
;
 
;
 
;
 
;
 
;
struct passwd *getpwnamallow(char const   *user ) 
;
 
;
 
;
 
;
static struct passwd fake  ;
struct passwd *fakepw(void) 
;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
 ;
extern u_int max_packet_size ;
 ;
extern int set_nonblock(int  ) ;
 ;
 ;
 ;
Kex *xxx_kex  ;
Authctxt *the_authctxt ;
static Buffer stdin_buffer  ;
static Buffer stdout_buffer  ;
static Buffer stderr_buffer  ;
static int fdin  ;
static int fdout  ;
static int fderr  ;
static long stdin_bytes  =    0L;
static long stdout_bytes  =    0L;
static long stderr_bytes  =    0L;
static long fdout_bytes  =    0L;
static int stdin_eof  =    0;
static int fdout_eof  =    0;
static int fderr_eof  =    0;
static int fdin_is_tty  =    0;
static int connection_in  ;
static int connection_out  ;
static int connection_closed  =    0;
static u_int buffer_high  ;
static int client_alive_timeouts  =    0;
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
 ;
static int notify_pipe[2]  ;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
static void client_alive_check(void) 
;




 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
 
;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
 ;
 ;
void initialize_server_options(ServerOptions *options___0 ) ;
void fill_default_server_options(ServerOptions *options___0 ) ;
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) ;
void load_server_config(char const   *filename , Buffer *conf ) ;
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) ;
 ;
 ;
extern long convtime(char const   * ) ;
 ;
 ;
 ;
 ;
void initialize_server_options(ServerOptions *options___0 ) 
;
void fill_default_server_options(ServerOptions *options___0 ) 
;
static struct __anonstruct_keywords_79 keywords[73]  = 
  {      {"usepam", (ServerOpCodes )64}, 
        {"pamauthenticationviakbdint", (ServerOpCodes )63}, 
        {"port", (ServerOpCodes )2}, 
        {"hostkey", (ServerOpCodes )3}, 
        {"hostdsakey", (ServerOpCodes )3}, 
        {"pidfile", (ServerOpCodes )43}, 
        {"serverkeybits", (ServerOpCodes )4}, 
        {"logingracetime", (ServerOpCodes )5}, 
        {"keyregenerationinterval", (ServerOpCodes )6}, 
        {"permitrootlogin", (ServerOpCodes )7}, 
        {"syslogfacility", (ServerOpCodes )8}, 
        {"loglevel", (ServerOpCodes )9}, 
        {"rhostsauthentication", (ServerOpCodes )63}, 
        {"rhostsrsaauthentication", (ServerOpCodes )10}, 
        {"hostbasedauthentication", (ServerOpCodes )52}, 
        {"hostbasedusesnamefrompacketonly", (ServerOpCodes )53}, 
        {"rsaauthentication", (ServerOpCodes )11}, 
        {"pubkeyauthentication", (ServerOpCodes )45}, 
        {"dsaauthentication", (ServerOpCodes )45}, 
        {"kerberosauthentication", (ServerOpCodes )64}, 
        {"kerberosorlocalpasswd", (ServerOpCodes )64}, 
        {"kerberosticketcleanup", (ServerOpCodes )64}, 
        {"kerberosgetafstoken", (ServerOpCodes )64}, 
        {"kerberostgtpassing", (ServerOpCodes )64}, 
        {"afstokenpassing", (ServerOpCodes )64}, 
        {"gssapiauthentication", (ServerOpCodes )64}, 
        {"gssapicleanupcredentials", (ServerOpCodes )64}, 
        {"passwordauthentication", (ServerOpCodes )18}, 
        {"kbdinteractiveauthentication", (ServerOpCodes )19}, 
        {"challengeresponseauthentication", (ServerOpCodes )17}, 
        {"skeyauthentication", (ServerOpCodes )17}, 
        {"checkmail", (ServerOpCodes )63}, 
        {"listenaddress", (ServerOpCodes )20}, 
        {"addressfamily", (ServerOpCodes )21}, 
        {"printmotd", (ServerOpCodes )22}, 
        {"printlastlog", (ServerOpCodes )23}, 
        {"ignorerhosts", (ServerOpCodes )24}, 
        {"ignoreuserknownhosts", (ServerOpCodes )39}, 
        {"x11forwarding", (ServerOpCodes )25}, 
        {"x11displayoffset", (ServerOpCodes )26}, 
        {"x11uselocalhost", (ServerOpCodes )27}, 
        {"xauthlocation", (ServerOpCodes )46}, 
        {"strictmodes", (ServerOpCodes )28}, 
        {"permitemptypasswords", (ServerOpCodes )29}, 
        {"permituserenvironment", (ServerOpCodes )31}, 
        {"uselogin", (ServerOpCodes )32}, 
        {"compression", (ServerOpCodes )34}, 
        {"tcpkeepalive", (ServerOpCodes )30}, 
        {"keepalive", (ServerOpCodes )30}, 
        {"allowtcpforwarding", (ServerOpCodes )33}, 
        {"allowusers", (ServerOpCodes )35}, 
        {"denyusers", (ServerOpCodes )36}, 
        {"allowgroups", (ServerOpCodes )37}, 
        {"denygroups", (ServerOpCodes )38}, 
        {"ciphers", (ServerOpCodes )40}, 
        {"macs", (ServerOpCodes )41}, 
        {"protocol", (ServerOpCodes )42}, 
        {"gatewayports", (ServerOpCodes )44}, 
        {"subsystem", (ServerOpCodes )47}, 
        {"maxstartups", (ServerOpCodes )48}, 
        {"maxauthtries", (ServerOpCodes )49}, 
        {"banner", (ServerOpCodes )50}, 
        {"usedns", (ServerOpCodes )51}, 
        {"verifyreversemapping", (ServerOpCodes )63}, 
        {"reversemappingcheck", (ServerOpCodes )63}, 
        {"clientaliveinterval", (ServerOpCodes )54}, 
        {"clientalivecountmax", (ServerOpCodes )55}, 
        {"authorizedkeysfile", (ServerOpCodes )56}, 
        {"authorizedkeysfile2", (ServerOpCodes )57}, 
        {"useprivilegeseparation", (ServerOpCodes )62}, 
        {"acceptenv", (ServerOpCodes )60}, 
        {"permittunnel", (ServerOpCodes )61}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
 
;
 
;
 
;
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) 
;
void load_server_config(char const   *filename , Buffer *conf ) 
;
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) 
;
 ;
 
;
 
;
 
;
 
;
 ;
 ;
 ;
 ;
 ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
 ;
 
;
 
;
 
;
 
;
 
;
 ;
 ;
 
;
 
;
 ;
 ;
 ;
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
 ;
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
extern int MD5_Init(MD5_CTX *c ) ;
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
 ;
extern void packet_put_bignum(BIGNUM *value ) ;
 ;
 
;
 
;
 
;
 
;
 
;
extern char *xcrypt(char const   *password , char const   *salt ) ;
extern char *shadow_pw(struct passwd *pw ) ;
void disable_forwarding(void) ;
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
void disable_forwarding(void) 
{ 
  {
  no_port_forwarding_flag = 1;
  no_agent_forwarding_flag = 1;
  no_x11_forwarding_flag = 1;
  return;
}
}
static int expire_checked  =    0;
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ 
  struct passwd *pw ;
  int result ;
  int ok ;
  int tmp ;
  int tmp___0 ;
  {
  pw = authctxt___0->pw;
  ok = authctxt___0->valid;
  {
  if (pw->pw_uid == 0U) {
    if (options.permit_root_login != 3) {
      ok = 0;
    }
  }
  }
  {
  if ((int const   )*password == 0) {
    if (options.permit_empty_passwd == 0) {
      return (0);
    }
  }
  }
  if (! expire_checked) {
    {
    expire_checked = 1;
    tmp = auth_shadow_pwexpired(authctxt___0);
    }
    if (tmp) {
      authctxt___0->force_pwchange = 1;
    }
  }
  {
  result = sys_auth_passwd(authctxt___0, password);
  }
  {
  if (authctxt___0->force_pwchange) {
    {
    disable_forwarding();
    }
  }
  }
  if (result) {
    if (ok) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ 
  struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  {
  pw = authctxt___0->pw;
  {
  if (authctxt___0->valid) {
    {
    tmp = shadow_pw(pw);
    tmp___0 = tmp;
    }
  } else {
    airac_observe(pw, 0);
    tmp___0 = pw->pw_passwd;
  }
  }
  {
  pw_password = tmp___0;
  tmp___1 = strcmp((char const   *)pw_password, "");
  }
  if (tmp___1 == 0) {
    {
    tmp___2 = strcmp(password, "");
    }
    if (tmp___2 == 0) {
      return (1);
    }
  }
  if (*(pw_password + 0)) {
    if (*(pw_password + 1)) {
      tmp___3 = (char const   *)pw_password;
    } else {
      tmp___3 = "xx";
    }
  } else {
    tmp___3 = "xx";
  }
  {
  encrypted_password = xcrypt(password, tmp___3);
  tmp___4 = strcmp((char const   *)encrypted_password, (char const   *)pw_password);
  }
  return (tmp___4 == 0);
}
}
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;


 ;
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
 
;
 
;
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
 ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
extern void closefrom(int  ) ;
extern void compat_init_setproctitle(int argc , char **argv ) ;
extern int BSDgetopt(int argc , char * const  *argv , char const   *opts ) ;
extern char *ssh_get_progname(char * ) ;
extern unsigned int arc4random(void) ;
extern void arc4random_stir(void) ;
extern void channel_set_af(int af ) ;
extern void seed_rng(void) ;
extern void init_rng(void) ;
 ;
extern int BN_mask_bits(BIGNUM *a , int n ) ;
 ;
extern int rsa_private_decrypt(BIGNUM * , BIGNUM * , RSA * ) ;
extern void rsa_generate_additional_parameters(RSA * ) ;
extern void packet_set_connection(int  , int  ) ;
extern void packet_set_nonblocking(void) ;
extern void packet_close(void) ;
extern void packet_set_server(void) ;
 ;
 ;
 ;
 ;
extern char *compat_cipher_proposal(char * ) ;
 ;
extern void buffer_get_bignum(Buffer * , BIGNUM * ) ;
extern void OPENSSL_add_all_algorithms_noconf(void) ;
extern u_int cipher_mask_ssh1(int  ) ;
extern char *cipher_name(int  ) ;
extern Key *key_new_private(int  ) ;
 ;
 ;
 ;
extern Kex *kex_setup(char ** ) ;
extern void derive_ssh1_session_id(BIGNUM * , BIGNUM * , u_int8_t * , u_int8_t * ) ;
static char *myproposal[10]  = 
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib@openssh.com,zlib",      (char *)"none,zlib@openssh.com,zlib", 
        (char *)"",      (char *)""};
extern Key *key_load_private(char const   * , char const   * , char ** ) ;
 ;
extern int unset_nonblock(int  ) ;
extern void sanitise_stdfd(void) ;
 ;
extern int ssh_msg_recv(int  , Buffer * ) ;
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
int debug_flag  =    0;
int test_flag  =    0;
int inetd_flag  =    0;
int no_daemon_flag  =    0;
int log_stderr  =    0;
char **saved_argv  ;
int saved_argc  ;
int rexeced_flag  =    0;
int rexec_flag  =    1;
int rexec_argc  =    0;
char **rexec_argv  ;
int listen_socks[16]  ;
int num_listen_socks  =    0;
char *client_version_string  =    (char *)((void *)0);
char *server_version_string  =    (char *)((void *)0);
struct __anonstruct_sensitive_data_82 sensitive_data  ;
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
static int volatile   received_sigterm___0  =    (sig_atomic_t volatile   )0;
u_char *session_id2  =    (u_char *)((void *)0);
u_int session_id2_len  =    (u_int )0;
u_int utmp_len  =    (u_int )64;
int *startup_pipes  =    (int *)((void *)0);
int startup_pipe  ;
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
 ;
static void do_ssh1_kex(void) ;
static void do_ssh2_kex(void) ;
static void close_listen_socks(void) 
;
static void close_startup_pipes(void) 
;
static void sighup_handler(int sig ) 
;
static void sighup_restart(void) 
;
static void sigterm_handler___0(int sig ) 
;
static void main_sigchld_handler(int sig ) 
;
static void grace_alarm_handler(int sig ) 
;
static void generate_ephemeral_server_key(void) 
;
static void key_regeneration_alarm(int sig ) 
;
static void sshd_exchange_identification(int sock_in , int sock_out ) 
;
void destroy_sensitive_data(void) 
;
 
;
 
;
static int privsep_preauth(Authctxt *authctxt___0 ) 
;
static void privsep_postauth(Authctxt *authctxt___0 ) 
;
static char *list_hostkey_types(void) 
;
Key *get_hostkey_by_type(int type ) 
;
 
;
int get_hostkey_index(Key *key ) 
;
static int drop_connection(int startups ) 
;
static void usage(void) 
;
static void send_rexec_state(int fd , Buffer *conf ) 
;
static void recv_rexec_state(int fd , Buffer *conf ) 
{ 
  Buffer m ;
  char *cp ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  {
  {
  debug3("%s: entering fd = %d", "recv_rexec_state", fd);
  buffer_init(& m);
  tmp = ssh_msg_recv(fd, & m);
  }
  if (tmp == -1) {
    {
    fatal("%s: ssh_msg_recv failed", "recv_rexec_state");
    }
  }
  {
  tmp___0 = buffer_get_char(& m);
  }
  if (tmp___0 != 0) {
    {
    fatal("%s: rexec version mismatch", "recv_rexec_state");
    }
  }
  {
  tmp___1 = buffer_get_string(& m, & len);
  cp = (char *)tmp___1;
  }
  if ((unsigned long )conf != (unsigned long )((void *)0)) {
    {
    buffer_append(conf, (void const   *)cp, len + 1U);
    }
  }
  {
  xfree((void *)cp);
  tmp___2 = buffer_get_int(& m);
  }
  if (tmp___2) {
    if ((unsigned long )sensitive_data.server_key != (unsigned long )((void *)0)) {
      {
      key_free(sensitive_data.server_key);
      }
    }
    {
    sensitive_data.server_key = key_new_private(0);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->e);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->n);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->d);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->iqmp);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->p);
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->q);
    rsa_generate_additional_parameters((sensitive_data.server_key)->rsa);
    }
  }
  {
  buffer_free(& m);
  debug3("%s: done", "recv_rexec_state");
  }
  return;
}
}
extern char *BSDoptarg ;
extern int BSDoptind ;
int main(int ac , char **av ) 
{ 
  int opt ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char *line ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int config_s[2] ;
  int startups ;
  Key *key ;
  Authctxt *authctxt___0 ;
  int ret ;
  int key_used ;
  Buffer cfg ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  void *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *pw ;
  struct stat st ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  int fd ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int fd___0 ;
  char const   *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  __pid_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  int *tmp___50 ;
  char *tmp___51 ;
  int *tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  __pid_t tmp___67 ;
  int fd___1 ;
  int *tmp___68 ;
  char *tmp___69 ;
  int *tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  void *tmp___74 ;
  int tmp___75 ;
  void *__cil_tmp195 ;
  void *__cil_tmp196 ;
  void *__cil_tmp197 ;
  void *__cil_tmp198 ;
  void *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  {
  {
  on = 1;
  sock_in = -1;
  sock_out = -1;
  newsock = -1;
  startup_p[0] = -1;
  startup_p[1] = -1;
  config_s[0] = -1;
  config_s[1] = -1;
  startups = 0;
  key_used = 0;
  __progname = ssh_get_progname(*(av + 0));
  init_rng();
  saved_argc = ac;
  rexec_argc = ac;
  tmp = xmalloc((size_t )(sizeof(*saved_argv) * (unsigned long )(ac + 1)));
  saved_argv = (char **)tmp;
  i = 0;
  }
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < ac)) {
      goto while_break;
    }
    {
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
    i ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: 
  {
  *(saved_argv + i) = (char *)((void *)0);
  compat_init_setproctitle(ac, av);
  av = saved_argv;
  tmp___2 = geteuid();
  }
  if (tmp___2 == 0U) {
    {
    tmp___3 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
    }
    if (tmp___3 == -1) {
      {
      tmp___0 = __errno_location();
      tmp___1 = strerror(*tmp___0);
      debug("setgroups(): %.200s", tmp___1);
      }
    }
  }
  {
  sanitise_stdfd();
  initialize_server_options(& options);
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:dDeiqrtQR46");
    }
    if (! (opt != -1)) {
      goto while_break___0;
    }
    if (opt == 52) {
      goto case_52;
    }
    if (opt == 54) {
      goto case_54;
    }
    if (opt == 102) {
      goto case_102;
    }
    if (opt == 100) {
      goto case_100;
    }
    if (opt == 68) {
      goto case_68;
    }
    if (opt == 101) {
      goto case_101;
    }
    if (opt == 105) {
      goto case_105;
    }
    if (opt == 114) {
      goto case_114;
    }
    if (opt == 82) {
      goto case_82;
    }
    if (opt == 81) {
      goto case_81;
    }
    if (opt == 113) {
      goto case_113;
    }
    if (opt == 98) {
      goto case_98;
    }
    if (opt == 112) {
      goto case_112;
    }
    if (opt == 103) {
      goto case_103;
    }
    if (opt == 107) {
      goto case_107;
    }
    if (opt == 104) {
      goto case_104;
    }
    if (opt == 116) {
      goto case_116;
    }
    if (opt == 117) {
      goto case_117;
    }
    if (opt == 111) {
      goto case_111;
    }
    goto switch_default;
    case_52: 
    options.address_family = 2;
    goto switch_break;
    case_54: 
    options.address_family = 10;
    goto switch_break;
    case_102: 
    config_file_name = BSDoptarg;
    goto switch_break;
    case_100: 
    if (debug_flag == 0) {
      debug_flag = 1;
      options.log_level = (LogLevel )5;
    } else
    if ((int )options.log_level < 7) {
      options.log_level = (LogLevel )((int )options.log_level + 1);
    }
    goto switch_break;
    case_68: 
    no_daemon_flag = 1;
    goto switch_break;
    case_101: 
    log_stderr = 1;
    goto switch_break;
    case_105: 
    inetd_flag = 1;
    goto switch_break;
    case_114: 
    rexec_flag = 0;
    goto switch_break;
    case_82: 
    rexeced_flag = 1;
    inetd_flag = 1;
    goto switch_break;
    case_81: 
    goto switch_break;
    case_113: 
    options.log_level = (LogLevel )0;
    goto switch_break;
    case_98: 
    {
    options.server_key_bits = atoi((char const   *)BSDoptarg);
    }
    goto switch_break;
    case_112: 
    options.ports_from_cmdline = (u_int )1;
    if (options.num_ports >= 256U) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many ports.\n");
      exit(1);
      }
    }
    {
    tmp___4 = options.num_ports;
    (options.num_ports) ++;
    tmp___5 = a2port((char const   *)BSDoptarg);
    options.ports[tmp___4] = (u_short )tmp___5;
    }
    if ((int )options.ports[options.num_ports - 1U] == 0) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad port number.\n");
      exit(1);
      }
    }
    goto switch_break;
    case_103: 
    {
    tmp___6 = convtime((char const   *)BSDoptarg);
    options.login_grace_time = (int )tmp___6;
    }
    if (options.login_grace_time == -1) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid login grace time.\n");
      exit(1);
      }
    }
    goto switch_break;
    case_107: 
    {
    tmp___7 = convtime((char const   *)BSDoptarg);
    options.key_regeneration_time = (int )tmp___7;
    }
    if (options.key_regeneration_time == -1) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid key regeneration interval.\n");
      exit(1);
      }
    }
    goto switch_break;
    case_104: 
    if (options.num_host_key_files >= 256) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many host keys.\n");
      exit(1);
      }
    }
    tmp___8 = options.num_host_key_files;
    (options.num_host_key_files) ++;
    options.host_key_files[tmp___8] = BSDoptarg;
    goto switch_break;
    case_116: 
    test_flag = 1;
    goto switch_break;
    case_117: 
    {
    tmp___9 = atoi((char const   *)BSDoptarg);
    utmp_len = (u_int )tmp___9;
    }
    if (utmp_len > 64U) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid utmp length.\n");
      exit(1);
      }
    }
    goto switch_break;
    case_111: 
    {
    line = xstrdup((char const   *)BSDoptarg);
    tmp___10 = process_server_config_line(& options, line, "command-line", 0);
    }
    if (tmp___10 != 0) {
      {
      exit(1);
      }
    }
    {
    xfree((void *)line);
    }
    goto switch_break;
    switch_default: 
    {
    usage();
    }
    goto switch_break;
    switch_break: ;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: ;
  if (rexeced_flag) {
    rexec_flag = 0;
  } else
  if (inetd_flag) {
    rexec_flag = 0;
  }
  if (rexec_flag) {
    if ((unsigned long )*(av + 0) == (unsigned long )((void *)0)) {
      {
      fatal("sshd re-exec requires execution with an absolute path");
      }
    } else
    if ((int )*(*(av + 0)) != 47) {
      {
      fatal("sshd re-exec requires execution with an absolute path");
      }
    }
  }
  if (rexeced_flag) {
    {
    closefrom(6);
    }
  } else {
    {
    closefrom(3);
    }
  }
  {
  OPENSSL_add_all_algorithms_noconf();
  }
  if (log_stderr) {
    tmp___11 = 1;
  } else
  if (! inetd_flag) {
    tmp___11 = 1;
  } else {
    tmp___11 = 0;
  }
  if ((int )options.log_facility == -1) {
    tmp___12 = 2;
  } else {
    tmp___12 = (int )options.log_facility;
  }
  if ((int )options.log_level == -1) {
    tmp___13 = 3;
  } else {
    tmp___13 = (int )options.log_level;
  }
  {
  log_init(__progname, (LogLevel )tmp___13, (SyslogFacility )tmp___12, tmp___11);
  tmp___14 = getenv("KRB5CCNAME");
  }
  if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
    {
    unsetenv("KRB5CCNAME");
    }
  }
  {
  sensitive_data.server_key = (Key *)((void *)0);
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
  sensitive_data.have_ssh1_key = 0;
  sensitive_data.have_ssh2_key = 0;
  buffer_init(& cfg);
  }
  if (rexeced_flag) {
    {
    recv_rexec_state(5, & cfg);
    }
  } else {
    {
    load_server_config((char const   *)config_file_name, & cfg);
    }
  }
  if (rexeced_flag) {
    tmp___15 = "rexec";
  } else {
    tmp___15 = (char const   *)config_file_name;
  }
  {
  parse_server_config(& options, tmp___15, & cfg);
  }
  if (! rexec_flag) {
    {
    buffer_free(& cfg);
    }
  }
  {
  seed_rng();
  fill_default_server_options(& options);
  channel_set_af(options.address_family);
  }
  if (BSDoptind < ac) {
    {
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extra argument %s.\n",
            *(av + BSDoptind));
    exit(1);
    }
  }
  {
  debug("sshd version %.100s", "OpenSSH_4.3p2");
  tmp___16 = xmalloc((size_t )((unsigned long )options.num_host_key_files * sizeof(Key *)));
  sensitive_data.host_keys = (Key **)tmp___16;
  i = 0;
  }
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i < options.num_host_key_files)) {
      goto while_break___1;
    }
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: 
  i = 0;
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    if (! (i < options.num_host_key_files)) {
      goto while_break___2;
    }
    {
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
    *(sensitive_data.host_keys + i) = key;
    }
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      {
      error("Could not load host key: %s", options.host_key_files[i]);
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      }
      goto __Cont;
    }
    if (key->type == 0) {
      goto case_0;
    }
    if (key->type == 2) {
      goto case_2;
    }
    if (key->type == 1) {
      goto case_2;
    }
    goto switch_break___0;
    case_0: 
    sensitive_data.ssh1_host_key = key;
    sensitive_data.have_ssh1_key = 1;
    goto switch_break___0;
    case_2: 
    sensitive_data.have_ssh2_key = 1;
    goto switch_break___0;
    switch_break___0: 
    {
    tmp___17 = key_type((Key const   *)key);
    debug("private host key: #%d type %d %s", i, key->type, tmp___17);
    }
    __Cont: 
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___2: ;
  if (options.protocol & 1) {
    if (! sensitive_data.have_ssh1_key) {
      {
      logit("Disabling protocol version 1. Could not load host key");
      options.protocol &= -2;
      }
    }
  }
  if (options.protocol & 4) {
    if (! sensitive_data.have_ssh2_key) {
      {
      logit("Disabling protocol version 2. Could not load host key");
      options.protocol &= -5;
      }
    }
  }
  if (! (options.protocol & 5)) {
    {
    logit("sshd: no hostkeys available -- exiting.");
    exit(1);
    }
  }
  if (options.protocol & 1) {
    if (options.server_key_bits < 512) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad server key size.\n");
      exit(1);
      }
    } else
    if (options.server_key_bits > 32768) {
      {
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad server key size.\n");
      exit(1);
      }
    }
    {
    tmp___19 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    }
    if (options.server_key_bits > tmp___19 - 128) {
      {
      tmp___20 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      }
      if (options.server_key_bits < tmp___20 + 128) {
        {
        tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
        options.server_key_bits = tmp___18 + 128;
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
        }
      }
    }
  }
  if (use_privsep) {
    {
    pw = getpwnam("sshd");
    }
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
      fatal("Privilege separation user %s does not exist", "sshd");
      }
    }
    {
    tmp___21 = stat((char const   */* __restrict  */)"/var/empty", (struct stat */* __restrict  */)(& st));
    }
    if (tmp___21 == -1) {
      {
      fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    } else
    if (((st.st_mode & 61440U) == 16384U) == 0) {
      {
      fatal("Missing privilege separation directory: %s", "/var/empty");
      }
    }
    if (st.st_uid != 0U) {
      {
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    } else
    if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
      {
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
    }
  }
  if (test_flag) {
    {
    exit(0);
    }
  }
  {
  tmp___24 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
  }
  if (tmp___24 < 0) {
    {
    tmp___22 = __errno_location();
    tmp___23 = strerror(*tmp___22);
    debug("setgroups() failed: %.200s", tmp___23);
    }
  }
  if (rexec_flag) {
    {
    tmp___25 = xmalloc((size_t )(sizeof(char *) * (unsigned long )(rexec_argc + 2)));
    rexec_argv = (char **)tmp___25;
    i = 0;
    }
    {
    while (1) {
      while_continue___3: /* CIL Label */ ;
      if (! (i < rexec_argc)) {
        goto while_break___3;
      }
      {
      debug("rexec_argv[%d]=\'%s\'", i, *(saved_argv + i));
      *(rexec_argv + i) = *(saved_argv + i);
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___3: 
    *(rexec_argv + rexec_argc) = (char *)"-R";
    *(rexec_argv + (rexec_argc + 1)) = (char *)((void *)0);
  }
  if (debug_flag) {
    if (! inetd_flag) {
      log_stderr = 1;
    } else
    if (rexeced_flag) {
      log_stderr = 1;
    }
  }
  {
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
  }
  if (! debug_flag) {
    if (! inetd_flag) {
      if (! no_daemon_flag) {
        {
        tmp___28 = daemon(0, 0);
        }
        if (tmp___28 < 0) {
          {
          tmp___26 = __errno_location();
          tmp___27 = strerror(*tmp___26);
          fatal("daemon() failed: %.200s", tmp___27);
          }
        }
        {
        fd = open("/dev/tty", 258);
        }
        if (fd >= 0) {
          {
          ioctl(fd, 21538UL, (void *)0);
          close(fd);
          }
        }
      }
    }
  }
  {
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
  arc4random_stir();
  chdir("/");
  mysignal(13, (void (*)(int  ))1);
  }
  if (inetd_flag) {
    startup_pipe = -1;
    if (rexeced_flag) {
      {
      close(5);
      sock_out = dup(0);
      sock_in = sock_out;
      }
      if (! debug_flag) {
        {
        startup_pipe = dup(4);
        close(4);
        }
      }
    } else {
      {
      sock_in = dup(0);
      sock_out = dup(1);
      }
    }
    {
    fd___0 = open("/dev/null", 2, 0);
    }
    if (fd___0 != -1) {
      {
      dup2(fd___0, 0);
      dup2(fd___0, 1);
      }
      if (fd___0 > 1) {
        {
        close(fd___0);
        }
      }
    }
    {
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
    }
    if (options.protocol & 1) {
      if ((unsigned long )sensitive_data.server_key == (unsigned long )((void *)0)) {
        {
        generate_ephemeral_server_key();
        }
      }
    }
  } else {
    ai = options.listen_addrs;
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! ai) {
        goto while_break___4;
      }
      if (ai->ai_family != 2) {
        if (ai->ai_family != 10) {
          goto __Cont___0;
        }
      }
      if (num_listen_socks >= 16) {
        {
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
        }
      }
      {
      ret = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)ai->ai_addr),
                        ai->ai_addrlen, (char */* __restrict  */)(ntop), (socklen_t )sizeof(ntop),
                        (char */* __restrict  */)(strport), (socklen_t )sizeof(strport),
                        3U);
      }
      if (ret != 0) {
        if (ret != -11) {
          {
          tmp___29 = gai_strerror(ret);
          tmp___32 = tmp___29;
          }
        } else {
          {
          tmp___30 = __errno_location();
          tmp___31 = strerror(*tmp___30);
          tmp___32 = (char const   *)tmp___31;
          }
        }
        {
        error("getnameinfo failed: %.100s", tmp___32);
        }
        goto __Cont___0;
      }
      {
      listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      }
      if (listen_sock < 0) {
        {
        tmp___33 = __errno_location();
        tmp___34 = strerror(*tmp___33);
        verbose("socket: %.100s", tmp___34);
        }
        goto __Cont___0;
      }
      {
      tmp___35 = set_nonblock(listen_sock);
      }
      if (tmp___35 == -1) {
        {
        close(listen_sock);
        }
        goto __Cont___0;
      }
      {
      tmp___38 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
      }
      if (tmp___38 == -1) {
        {
        tmp___36 = __errno_location();
        tmp___37 = strerror(*tmp___36);
        error("setsockopt SO_REUSEADDR: %s", tmp___37);
        }
      }
      {
      debug("Bind to port %s on %s.", strport, ntop);
      tmp___41 = bind(listen_sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr  const  *)ai->ai_addr),
                      ai->ai_addrlen);
      }
      if (tmp___41 < 0) {
        if (! ai->ai_next) {
          {
          tmp___39 = __errno_location();
          tmp___40 = strerror(*tmp___39);
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___40);
          }
        }
        {
        close(listen_sock);
        }
        goto __Cont___0;
      }
      {
      listen_socks[num_listen_socks] = listen_sock;
      num_listen_socks ++;
      logit("Server listening on %s port %s.", ntop, strport);
      tmp___44 = listen(listen_sock, 128);
      }
      if (tmp___44 < 0) {
        {
        tmp___42 = __errno_location();
        tmp___43 = strerror(*tmp___42);
        fatal("listen: %.100s", tmp___43);
        }
      }
      __Cont___0: 
      ai = ai->ai_next;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___4: 
    {
    freeaddrinfo(options.listen_addrs);
    }
    if (! num_listen_socks) {
      {
      fatal("Cannot bind any address.");
      }
    }
    if (options.protocol & 1) {
      {
      generate_ephemeral_server_key();
      }
    }
    {
    mysignal(1, & sighup_handler);
    mysignal(15, & sigterm_handler___0);
    mysignal(3, & sigterm_handler___0);
    mysignal(17, & main_sigchld_handler);
    }
    if (! debug_flag) {
      {
      f = fopen((char const   */* __restrict  */)((char const   *)options.pid_file),
                (char const   */* __restrict  */)"wb");
      }
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
        tmp___45 = __errno_location();
        tmp___46 = strerror(*tmp___45);
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___46);
        }
      } else {
        {
        tmp___47 = getpid();
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld\n",
                (long )tmp___47);
        fclose(f);
        }
      }
    }
    fdset = (fd_set *)((void *)0);
    maxfd = 0;
    i = 0;
    {
    while (1) {
      while_continue___5: /* CIL Label */ ;
      if (! (i < num_listen_socks)) {
        goto while_break___5;
      }
      if (listen_socks[i] > maxfd) {
        maxfd = listen_socks[i];
      }
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___5: 
    {
    tmp___48 = xmalloc((size_t )((unsigned long )options.max_startups * sizeof(int )));
    startup_pipes = (int *)tmp___48;
    i = 0;
    }
    {
    while (1) {
      while_continue___6: /* CIL Label */ ;
      if (! (i < options.max_startups)) {
        goto while_break___6;
      }
      *(startup_pipes + i) = -1;
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___6: ;
    {
    while (1) {
      while_continue___7: /* CIL Label */ ;
      if (received_sighup) {
        {
        sighup_restart();
        }
      }
      if ((unsigned long )fdset != (unsigned long )((void *)0)) {
        {
        xfree((void *)fdset);
        }
      }
      {
      fdsetsz = (int )((((unsigned long )(maxfd + 1) + (8UL * sizeof(__fd_mask ) - 1UL)) / (8UL * sizeof(__fd_mask ))) * sizeof(fd_mask ));
      tmp___49 = xmalloc((size_t )fdsetsz);
      fdset = (fd_set *)tmp___49;
      memset((void *)fdset, 0, (size_t )fdsetsz);
      i = 0;
      }
      {
      while (1) {
        while_continue___8: /* CIL Label */ ;
        if (! (i < num_listen_socks)) {
          goto while_break___8;
        }
        fdset->fds_bits[(unsigned long )listen_socks[i] / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )listen_socks[i] % (8UL * sizeof(__fd_mask ));
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: 
      i = 0;
      {
      while (1) {
        while_continue___9: /* CIL Label */ ;
        if (! (i < options.max_startups)) {
          goto while_break___9;
        }
        if (*(startup_pipes + i) != -1) {
          fdset->fds_bits[(unsigned long )*(startup_pipes + i) / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )*(startup_pipes + i) % (8UL * sizeof(__fd_mask ));
        }
        i ++;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: 
      {
      ret = select(maxfd + 1, (fd_set */* __restrict  */)fdset, (fd_set */* __restrict  */)((fd_set *)((void *)0)),
                   (fd_set */* __restrict  */)((fd_set *)((void *)0)), (struct timeval */* __restrict  */)((struct timeval *)((void *)0)));
      }
      if (ret < 0) {
        {
        tmp___52 = __errno_location();
        }
        if (*tmp___52 != 4) {
          {
          tmp___50 = __errno_location();
          tmp___51 = strerror(*tmp___50);
          error("select: %.100s", tmp___51);
          }
        }
      }
      if (received_sigterm___0) {
        {
        logit("Received signal %d; terminating.", (int )received_sigterm___0);
        close_listen_socks();
        unlink((char const   *)options.pid_file);
        exit(255);
        }
      }
      if (key_used) {
        if (key_do_regen) {
          {
          generate_ephemeral_server_key();
          key_used = 0;
          key_do_regen = (int volatile   )0;
          }
        }
      }
      if (ret < 0) {
        goto __Cont___1;
      }
      i = 0;
      {
      while (1) {
        while_continue___10: /* CIL Label */ ;
        if (! (i < options.max_startups)) {
          goto while_break___10;
        }
        if (*(startup_pipes + i) != -1) {
          if ((fdset->fds_bits[(unsigned long )*(startup_pipes + i) / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )*(startup_pipes + i) % (8UL * sizeof(__fd_mask )))) != 0L) {
            {
            close(*(startup_pipes + i));
            *(startup_pipes + i) = -1;
            startups --;
            }
          }
        }
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: 
      i = 0;
      {
      while (1) {
        while_continue___11: /* CIL Label */ ;
        if (! (i < num_listen_socks)) {
          goto while_break___11;
        }
        if (! ((fdset->fds_bits[(unsigned long )listen_socks[i] / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )listen_socks[i] % (8UL * sizeof(__fd_mask )))) != 0L)) {
          goto __Cont___2;
        }
        {
        fromlen = (socklen_t )sizeof(from);
        newsock = accept(listen_socks[i], (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                         (socklen_t */* __restrict  */)(& fromlen));
        }
        if (newsock < 0) {
          {
          tmp___55 = __errno_location();
          }
          if (*tmp___55 != 4) {
            {
            tmp___56 = __errno_location();
            }
            if (*tmp___56 != 11) {
              {
              tmp___53 = __errno_location();
              tmp___54 = strerror(*tmp___53);
              error("accept: %.100s", tmp___54);
              }
            }
          }
          goto __Cont___2;
        }
        {
        tmp___57 = unset_nonblock(newsock);
        }
        if (tmp___57 == -1) {
          {
          close(newsock);
          }
          goto __Cont___2;
        }
        {
        tmp___58 = drop_connection(startups);
        }
        if (tmp___58 == 1) {
          {
          debug("drop connection #%d", startups);
          close(newsock);
          }
          goto __Cont___2;
        }
        {
        tmp___59 = pipe(startup_p);
        }
        if (tmp___59 == -1) {
          {
          close(newsock);
          }
          goto __Cont___2;
        }
        if (rexec_flag) {
          {
          tmp___62 = socketpair(1, 1, 0, config_s);
          }
          if (tmp___62 == -1) {
            {
            tmp___60 = __errno_location();
            tmp___61 = strerror(*tmp___60);
            error("reexec socketpair: %s", tmp___61);
            close(newsock);
            close(startup_p[0]);
            close(startup_p[1]);
            }
            goto __Cont___2;
          }
        }
        j = 0;
        {
        while (1) {
          while_continue___12: /* CIL Label */ ;
          if (! (j < options.max_startups)) {
            goto while_break___12;
          }
          if (*(startup_pipes + j) == -1) {
            *(startup_pipes + j) = startup_p[0];
            if (maxfd < startup_p[0]) {
              maxfd = startup_p[0];
            }
            startups ++;
            goto while_break___12;
          }
          j ++;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: ;
        if (debug_flag) {
          {
          debug("Server will not fork when running in debugging mode.");
          close_listen_socks();
          sock_in = newsock;
          sock_out = newsock;
          close(startup_p[0]);
          close(startup_p[1]);
          startup_pipe = -1;
          pid = getpid();
          }
          if (rexec_flag) {
            {
            send_rexec_state(config_s[0], & cfg);
            close(config_s[0]);
            }
          }
          goto while_break___11;
        } else {
          {
          pid = fork();
          }
          if (pid == 0) {
            {
            startup_pipe = startup_p[1];
            close_startup_pipes();
            close_listen_socks();
            sock_in = newsock;
            sock_out = newsock;
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
            }
            if (rexec_flag) {
              {
              close(config_s[0]);
              }
            }
            goto while_break___11;
          }
        }
        if (pid < 0) {
          {
          tmp___63 = __errno_location();
          tmp___64 = strerror(*tmp___63);
          error("fork: %.100s", tmp___64);
          }
        } else {
          {
          debug("Forked child %ld.", (long )pid);
          }
        }
        {
        close(startup_p[1]);
        }
        if (rexec_flag) {
          {
          send_rexec_state(config_s[0], & cfg);
          close(config_s[0]);
          close(config_s[1]);
          }
        }
        if (options.protocol & 1) {
          if (key_used == 0) {
            {
            mysignal(14, & key_regeneration_alarm);
            alarm((unsigned int )options.key_regeneration_time);
            key_used = 1;
            }
          }
        }
        {
        arc4random_stir();
        close(newsock);
        }
        __Cont___2: 
        i ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: ;
      if (num_listen_socks < 0) {
        goto while_break___7;
      }
      __Cont___1: ;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___7: ;
  }
  {
  setproctitle("%s", "[accepted]");
  }
  if (! debug_flag) {
    if (! inetd_flag) {
      {
      tmp___67 = setsid();
      }
      if (tmp___67 < 0) {
        {
        tmp___65 = __errno_location();
        tmp___66 = strerror(*tmp___65);
        error("setsid: %.100s", tmp___66);
        }
      }
    }
  }
  if (rexec_flag) {
    {
    debug("rexec start in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
    dup2(newsock, 0);
    dup2(0, 1);
    }
    if (startup_pipe == -1) {
      {
      close(4);
      }
    } else {
      {
      dup2(startup_pipe, 4);
      }
    }
    {
    dup2(config_s[1], 5);
    close(config_s[1]);
    }
    if (startup_pipe != -1) {
      {
      close(startup_pipe);
      }
    }
    {
    execv((char const   *)*(rexec_argv + 0), (char * const  *)rexec_argv);
    tmp___68 = __errno_location();
    tmp___69 = strerror(*tmp___68);
    error("rexec of %s failed: %s", *(rexec_argv + 0), tmp___69);
    recv_rexec_state(5, (Buffer *)((void *)0));
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
    startup_pipe = 4;
    close(config_s[1]);
    close(5);
    sock_in = dup(0);
    sock_out = sock_in;
    newsock = sock_out;
    fd___1 = open("/dev/null", 2, 0);
    }
    if (fd___1 != -1) {
      {
      dup2(fd___1, 0);
      dup2(fd___1, 1);
      }
      if (fd___1 > 2) {
        {
        close(fd___1);
        }
      }
    }
    {
    debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
    }
  }
  {
  alarm(0U);
  mysignal(14, (void (*)(int  ))0);
  mysignal(1, (void (*)(int  ))0);
  mysignal(15, (void (*)(int  ))0);
  mysignal(3, (void (*)(int  ))0);
  mysignal(17, (void (*)(int  ))0);
  mysignal(2, (void (*)(int  ))0);
  packet_set_connection(sock_in, sock_out);
  packet_set_server();
  }
  if (options.tcp_keep_alive) {
    {
    tmp___72 = packet_connection_is_on_socket();
    }
    if (tmp___72) {
      {
      tmp___73 = setsockopt(sock_in, 1, 9, (void const   *)(& on), (socklen_t )sizeof(on));
      }
      if (tmp___73 < 0) {
        {
        tmp___70 = __errno_location();
        tmp___71 = strerror(*tmp___70);
        error("setsockopt SO_KEEPALIVE: %.100s", tmp___71);
        }
      }
    }
  }
  {
  remote_port = get_remote_port();
  }
  if (remote_port < 0) {
    {
    debug("get_remote_port failed");
    cleanup_exit(255);
    }
  }
  {
  remote_ip = get_canonical_hostname(0);
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
  mysignal(14, & grace_alarm_handler);
  }
  if (! debug_flag) {
    {
    alarm((unsigned int )options.login_grace_time);
    }
  }
  {
  sshd_exchange_identification(sock_in, sock_out);
  packet_set_nonblocking();
  tmp___74 = xmalloc((size_t )sizeof(*authctxt___0));
  authctxt___0 = (Authctxt *)tmp___74;
  memset((void *)authctxt___0, 0, (size_t )sizeof(*authctxt___0));
  authctxt___0->loginmsg = & loginmsg;
  the_authctxt = authctxt___0;
  buffer_init(& loginmsg);
  }
  if (use_privsep) {
    {
    tmp___75 = privsep_preauth(authctxt___0);
    }
    if (tmp___75 == 1) {
      goto authenticated;
    }
  }
  if (compat20) {
    {
    do_ssh2_kex();
    do_authentication2(authctxt___0);
    }
  } else {
    {
    do_ssh1_kex();
    do_authentication(authctxt___0);
    }
  }
  if (use_privsep) {
    {
    mm_send_keystate(pmonitor);
    exit(0);
    }
  }
  authenticated: 
  {
  alarm(0U);
  mysignal(14, (void (*)(int  ))0);
  }
  if (startup_pipe != -1) {
    {
    close(startup_pipe);
    startup_pipe = -1;
    }
  }
  if (use_privsep) {
    {
    privsep_postauth(authctxt___0);
    }
    if (! compat20) {
      {
      destroy_sensitive_data();
      }
    }
  }
  {
  do_authenticated(authctxt___0);
  verbose("Closing connection to %.100s", remote_ip);
  packet_close();
  }
  if (use_privsep) {
    {
    mm_terminate();
    }
  }
  {
  exit(0);
  }
}
}
int ssh1_session_key(BIGNUM *session_key_int ) 
{ 
  int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  {
  {
  rsafail = 0;
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  }
  if (tmp___13 > 0) {
    {
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    }
    if (tmp___2 < tmp___3 + 128) {
      {
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
      tmp___1 = get_remote_ipaddr();
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
      }
    }
    {
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
    }
    if (tmp___4 <= 0) {
      rsafail ++;
    }
    {
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
    }
    if (tmp___5 <= 0) {
      rsafail ++;
    }
  } else {
    {
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
    }
    if (tmp___9 < tmp___10 + 128) {
      {
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      tmp___8 = get_remote_ipaddr();
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
      }
    }
    {
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
    }
    if (tmp___11 < 0) {
      rsafail ++;
    }
    {
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
    }
    if (tmp___12 < 0) {
      rsafail ++;
    }
  }
  return (rsafail);
}
}
static void do_ssh1_kex(void) 
{ 
  int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rnd ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  {
  rsafail = 0;
  rnd = (u_int32_t )0;
  i = 0;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < 8)) {
      goto while_break;
    }
    if (i % 4 == 0) {
      {
      rnd = arc4random();
      }
    }
    cookie[i] = (u_char )(rnd & 255U);
    rnd >>= 8;
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: 
  {
  packet_start((u_char )2);
  i = 0;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    if (! (i < 8)) {
      goto while_break___0;
    }
    {
    packet_put_char((int )cookie[i]);
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: 
  {
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
  packet_put_int((u_int )tmp);
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  packet_put_int((u_int )tmp___0);
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
  packet_put_int((u_int )2);
  tmp___1 = cipher_mask_ssh1(0);
  packet_put_int(tmp___1);
  auth_mask = (u_int )0;
  }
  if (options.rhosts_rsa_authentication) {
    auth_mask |= (unsigned int )(1 << 4);
  }
  if (options.rsa_authentication) {
    auth_mask |= (unsigned int )(1 << 2);
  }
  if (options.challenge_response_authentication == 1) {
    auth_mask |= (unsigned int )(1 << 5);
  }
  if (options.password_authentication) {
    auth_mask |= (unsigned int )(1 << 3);
  }
  {
  packet_put_int(auth_mask);
  packet_send();
  packet_write_wait();
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
  packet_read_expect(3);
  cipher_type = packet_get_char();
  tmp___4 = cipher_mask_ssh1(0);
  }
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
    {
    packet_disconnect("Warning: client selects unsupported cipher.");
    }
  }
  i = 0;
  {
  while (1) {
    while_continue___1: /* CIL Label */ ;
    if (! (i < 8)) {
      goto while_break___1;
    }
    {
    tmp___5 = packet_get_char();
    }
    if ((u_int )cookie[i] != tmp___5) {
      {
      packet_disconnect("IP Spoofing check bytes do not match.");
      }
    }
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: 
  {
  tmp___6 = cipher_name((int )cipher_type);
  debug("Encryption type: %.200s", tmp___6);
  session_key_int = BN_new();
  }
  if ((unsigned long )session_key_int == (unsigned long )((void *)0)) {
    {
    fatal("do_ssh1_kex: BN_new failed");
    }
  }
  {
  packet_get_bignum(session_key_int);
  protocol_flags = packet_get_int();
  packet_set_protocol_flags(protocol_flags);
  }
  {
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
    tmp___7 = packet_remaining();
    _len = tmp___7;
    }
    if (_len > 0) {
      {
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c",
            1920);
      packet_disconnect("Packet integrity error.");
      }
    }
    goto while_break___2;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: ;
  if (use_privsep) {
    {
    tmp___8 = mm_ssh1_session_key(session_key_int);
    rsafail = tmp___8;
    }
  } else {
    {
    tmp___9 = ssh1_session_key(session_key_int);
    rsafail = tmp___9;
    }
  }
  if (! rsafail) {
    {
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8UL));
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
    len = (tmp___10 + 7) / 8;
    }
    if (len < 0) {
      {
      tmp___11 = get_remote_ipaddr();
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, sizeof(session_key));
      rsafail ++;
      }
    } else
    if ((unsigned long )((u_int )len) > sizeof(session_key)) {
      {
      tmp___11 = get_remote_ipaddr();
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, sizeof(session_key));
      rsafail ++;
      }
    } else {
      {
      memset((void *)(session_key), 0, (size_t )sizeof(session_key));
      BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
      derive_ssh1_session_id(((sensitive_data.ssh1_host_key)->rsa)->n, ((sensitive_data.server_key)->rsa)->n,
                             cookie, session_id);
      i = 0;
      }
      {
      while (1) {
        while_continue___3: /* CIL Label */ ;
        if (! (i < 16)) {
          goto while_break___3;
        }
        session_key[i] = (u_char )((int )session_key[i] ^ (int )session_id[i]);
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: ;
    }
  }
  if (rsafail) {
    {
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
    bytes = (tmp___12 + 7) / 8;
    tmp___13 = xmalloc((size_t )bytes);
    buf___1 = (u_char *)tmp___13;
    logit("do_connection: generating a fake encryption key");
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
    MD5_Init(& md);
    MD5_Update(& md, (void const   *)buf___1, (size_t )bytes);
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), (size_t )32);
    MD5_Final(session_key, & md);
    MD5_Init(& md);
    MD5_Update(& md, (void const   *)(session_key), (size_t )16);
    MD5_Update(& md, (void const   *)buf___1, (size_t )bytes);
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), (size_t )32);
    MD5_Final(session_key + 16, & md);
    memset((void *)buf___1, 0, (size_t )bytes);
    xfree((void *)buf___1);
    i = 0;
    }
    {
    while (1) {
      while_continue___4: /* CIL Label */ ;
      if (! (i < 16)) {
        goto while_break___4;
      }
      session_id[i] = (u_char )((int )session_key[i] ^ (int )session_key[i + 16]);
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: ;
  }
  {
  destroy_sensitive_data();
  }
  if (use_privsep) {
    {
    mm_ssh1_session_id(session_id);
    }
  }
  {
  BN_clear_free(session_key_int);
  packet_set_encryption_key((u_char const   *)(session_key), (u_int )32, (int )cipher_type);
  memset((void *)(session_key), 0, (size_t )sizeof(session_key));
  debug("Received session key; encryption turned on.");
  packet_start((u_char )14);
  packet_send();
  packet_write_wait();
  }
  return;
}
}
static void do_ssh2_kex(void) 
{ 
  Kex *kex ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  {
  if ((unsigned long )options.ciphers != (unsigned long )((void *)0)) {
    myproposal[3] = options.ciphers;
    myproposal[2] = myproposal[3];
  }
  {
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
  }
  if ((unsigned long )options.macs != (unsigned long )((void *)0)) {
    myproposal[5] = options.macs;
    myproposal[4] = myproposal[5];
  }
  if (options.compression == 0) {
    myproposal[7] = (char *)"none";
    myproposal[6] = myproposal[7];
  } else
  if (options.compression == 2) {
    myproposal[7] = (char *)"none,zlib@openssh.com";
    myproposal[6] = myproposal[7];
  }
  {
  myproposal[1] = list_hostkey_types();
  kex = kex_setup(myproposal);
  kex->kex[0] = & kexdh_server;
  kex->kex[1] = & kexdh_server;
  kex->kex[2] = & kexgex_server;
  kex->server = 1;
  kex->client_version_string = client_version_string;
  kex->server_version_string = server_version_string;
  kex->load_host_key = & get_hostkey_by_type;
  kex->host_key_index = & get_hostkey_index;
  xxx_kex = kex;
  dispatch_run(0, & kex->done, (void *)kex);
  session_id2 = kex->session_id;
  session_id2_len = kex->session_id_len;
  debug("KEX done");
  }
  return;
}
}
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
void cleanup_exit(int i ) 
{ 
  {
  if (the_authctxt) {
    {
    do_cleanup(the_authctxt);
    }
  }
  {
  _exit(i);
  }
}
}
