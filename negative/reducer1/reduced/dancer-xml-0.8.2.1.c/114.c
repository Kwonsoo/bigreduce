/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
struct dxml_attribute {
   char *attribute_name ;
   char *attribute_data ;
   struct dxml_attribute *next ;
};
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
typedef struct dxml_attribute dxml_attribute;
#line 53
enum element_type {
    element_type_element = 0,
    element_type_pcdata = 1
} ;
#line 53 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
struct dxml_element {
   char *element_name ;
   enum element_type element_type ;
   dxml_attribute *element_attribute ;
   struct dxml_element *child ;
   struct dxml_element *next ;
};
#line 53 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
typedef struct dxml_element dxml_element;
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 668
extern int puts(char const   *__s ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 181
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 152 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 77 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
dxml_element *dxml_read_xml(FILE *f ) ;
#line 83
dxml_element *dxml_get_element_byname(dxml_element *e , char const   *name ) ;
#line 86
dxml_element *dxml_get_element_bysimplepath(dxml_element *e , char const   *path ) ;
#line 89
void dxml_dump_element(dxml_element *e ) ;
#line 92
char *dxml_get_PCDATA_bysimplepath(dxml_element *e , char const   *path ) ;
#line 30 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int replace_external_entity(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 33
  tmp___1 = strcmp(s, "gt");
  }
#line 33
  if (tmp___1) {
    {
#line 35
    tmp___0 = strcmp(s, "lt");
    }
#line 35
    if (tmp___0) {
      {
#line 37
      tmp = strcmp(s, "amp");
      }
#line 37
      if (tmp) {
        {
#line 41
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown entity %s\n",
                s);
#line 42
        exit(1);
        }
      } else {
        {
#line 38
        printf((char const   */* __restrict  */)"\\&{}");
        }
      }
    } else {
      {
#line 36
      printf((char const   */* __restrict  */)"$<$");
      }
    }
  } else {
    {
#line 34
    printf((char const   */* __restrict  */)"$>$");
    }
  }
#line 44
  return (0);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int convert_print(char const   *s , int verbatim ) 
{ 
  char const   *endptr ;
  unsigned short const   **tmp ;
  char *tmps ;
  char *tmp___0 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 55
  endptr = (char const   *)((void *)0);
#line 57
  if (! s) {
#line 59
    return (1);
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;


    {

    {

#line 62
    if (*s) {
      {
#line 62
      tmp = __ctype_b_loc();
      }
      {

#line 62
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 62
        goto while_break;
      }
      }
    } else {
#line 62
      goto while_break;
    }
    }
    }
#line 64
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;


    {

#line 66
    if (! *s) {
#line 66
      goto while_break___0;
    }
    }
    {

#line 70
    if ((int const   )*s == 36) {
#line 70
      goto case_36;
    }
    }
    {

#line 73
    if ((int const   )*s == 95) {
#line 73
      goto case_95;
    }
    }
    {

#line 76
    if ((int const   )*s == 92) {
#line 76
      goto case_92;
    }
    }
    {

#line 79
    if ((int const   )*s == 94) {
#line 79
      goto case_94;
    }
    }
    {

#line 82
    if ((int const   )*s == 126) {
#line 82
      goto case_126;
    }
    }
    {

#line 85
    if ((int const   )*s == 10) {
#line 85
      goto case_10;
    }
    }
    {

#line 89
    if ((int const   )*s == 35) {
#line 89
      goto case_35;
    }
    }
    {

#line 92
    if ((int const   )*s == 91) {
#line 92
      goto case_91;
    }
    }
    {

#line 95
    if ((int const   )*s == 93) {
#line 95
      goto case_93;
    }
    }
    {

#line 99
    if ((int const   )*s == 38) {
#line 99
      goto case_38;
    }
    }
#line 114
    goto switch_default;
    case_36: 
    {
#line 71
    printf((char const   */* __restrict  */)"\\${}");
    }
#line 72
    goto switch_break;
    case_95: 
    {
#line 74
    printf((char const   */* __restrict  */)"\\underline{ }");
    }
#line 75
    goto switch_break;
    case_92: 
    {
#line 77
    printf((char const   */* __restrict  */)"\\verb\'\\\'");
    }
#line 78
    goto switch_break;
    case_94: 
    {
#line 80
    printf((char const   */* __restrict  */)"\\verb!^!");
    }
#line 81
    goto switch_break;
    case_126: 
    {
#line 83
    printf((char const   */* __restrict  */)"\\~\\ ");
    }
#line 84
    goto switch_break;
    case_10: 
#line 86
    if (verbatim) {
      {
#line 86
      printf((char const   */* __restrict  */)"\\\\%%");
      }
    }
    {
#line 87
    printf((char const   */* __restrict  */)"\n");
    }
#line 88
    goto switch_break;
    case_35: 
    {
#line 90
    printf((char const   */* __restrict  */)"$\\sharp$");
    }
#line 91
    goto switch_break;
    case_91: 
    {
#line 93
    printf((char const   */* __restrict  */)"{}[{}");
    }
#line 94
    goto switch_break;
    case_93: 
    {
#line 96
    printf((char const   */* __restrict  */)"{}]{}");
    }
#line 97
    goto switch_break;
    case_38: 
    {
#line 100
    tmp___0 = strchr(s, ';');
#line 100
    endptr = (char const   *)tmp___0;
    }
#line 100
    if ((unsigned long )((void *)0) != (unsigned long )endptr) {
      {
#line 103
      tmps = strndup(s + 1, (size_t )((endptr - s) - 1L));
#line 104
      replace_external_entity((char const   *)tmps);
#line 105
      free((void *)tmps);
#line 106
      s = endptr;
      }
    } else {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated & \n");
#line 111
      exit(1);
      }
    }
#line 113
    goto switch_break;
    switch_default: 
    {
#line 115
    _IO_putc((int )*s, stdout);
    }
    switch_break: 
#line 118
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 122
  return (0);
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static char const   *getatrstring(dxml_element *e , char const   *attr ) 
{ 
  dxml_attribute *a ;
  int tmp ;

  {
#line 127
  a = e->element_attribute;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;


#line 128
    if (! a) {
#line 128
      goto while_break;
    }
    {
#line 130
    tmp = strcmp((char const   *)a->attribute_name, attr);
    }
#line 130
    if (! tmp) {
      {

#line 131
      return ((char const   *)a->attribute_data);
      }
    }
#line 132
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 134
  return ((char const   *)((void *)0));
}
}
#line 137
static int get_paratype(dxml_element *b , int verbatim ) ;
#line 138
static int get_bookchapter(dxml_element *b , int paraenter ) ;
#line 140 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int maybe_label(dxml_element *b ) 
{ 
  char const   *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 144
  s = getatrstring(b, "id");
  }
#line 144
  if (s) {
    {
#line 145
    printf((char const   */* __restrict  */)"\\label{%s}\n", s);
    }
  }
#line 146
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_table(dxml_element *b_parent ) 
{ 
  int i ;
  int width ;
  dxml_element *row ;
  dxml_element *entry ;
  dxml_element *b ;
  int columns ;
  dxml_element *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 154
  b = b_parent->child;
#line 155
  tmp = dxml_get_element_byname(b, "tgroup");
#line 155
  tmp___0 = getatrstring(tmp, "cols");
#line 155
  tmp___1 = atoi(tmp___0);
#line 155
  columns = tmp___1;
#line 156
  tmp___2 = dxml_get_PCDATA_bysimplepath(b, "title");
#line 156
  printf((char const   */* __restrict  */)"\\begin{table}\n\\caption{%s}\n", tmp___2);
#line 159
  maybe_label(b_parent);
#line 161
  width = 12 / columns;
#line 162
  printf((char const   */* __restrict  */)"\\begin{tabular}{p{%icm}", width);
#line 163
  i = 0;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;


#line 163
    if (! (i < columns - 1)) {
#line 163
      goto while_break;
    }
    {
#line 164
    printf((char const   */* __restrict  */)"|p{%icm}", width);
#line 163
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break: 
  {
#line 165
  printf((char const   */* __restrict  */)"}\n\\hline\n\\hline\n");
#line 166
  row = dxml_get_element_bysimplepath(b, "tgroup/tbody/row");
  }
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;


#line 166
    if (! row) {
#line 166
      goto while_break___0;
    }
#line 168
    entry = row->child;
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;


#line 168
      if (! entry) {
#line 168
        goto while_break___1;
      }
      {
#line 170
      get_paratype(entry->child, 0);
      }
      {

#line 171
      if (entry->next) {
        {
#line 172
        printf((char const   */* __restrict  */)" & ");
        }
      }
      }
#line 168
      entry = entry->next;
    }
    while_break___4: /* CIL Label */ ;
    }

    while_break___1: 
    {
#line 176
    printf((char const   */* __restrict  */)"\\\\\n");
#line 166
    row = row->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }

  while_break___0: 
  {
#line 178
  printf((char const   */* __restrict  */)"\\hline\n\\hline\n\\end{tabular}\n\\end{table}\n");
  }
#line 183
  return (0);
}
}
#line 186 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_itemizedlist(dxml_element *b ) 
{ 
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 188
  printf((char const   */* __restrict  */)"\\begin{itemize}\n");
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;


#line 189
    if (! b) {
#line 189
      goto while_break;
    }
    {
#line 192
    tmp = strcasecmp("listitem", (char const   *)b->element_name);
    }
#line 192
    if (tmp) {
      {
#line 199
      dxml_dump_element(b);
      }
    } else {
      {
#line 194
      printf((char const   */* __restrict  */)"\\item ");
#line 195
      get_bookchapter(b->child, 0);
#line 196
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 201
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 203
  printf((char const   */* __restrict  */)"\\end{itemize}\n");
  }
#line 204
  return (0);
}
}
#line 213 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bothtypes(dxml_element *b , int inlinetype ) 
{ 
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 215
  tmp = strcasecmp("screen", (char const   *)b->element_name);
  }
#line 215
  if (tmp) {
#line 226
    return (0);
  } else {
#line 217
    if (! inlinetype) {
      {
#line 218
      puts("\n\n\n\n");
      }
    }
    {
#line 219
    puts("{\\tt %\n");
#line 220
    get_paratype(b->child, 1);
#line 221
    puts("}");
    }
#line 222
    if (! inlinetype) {
      {
#line 223
      puts("\n\n\n\n");
      }
    }
  }
#line 227
  return (1);
}
}
#line 234 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_paratype(dxml_element *b , int verbatim ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;


#line 238
    if (! b) {
#line 238
      goto while_break;
    }
    {

#line 240
    if ((unsigned int )b->element_type == 1U) {
      {
#line 242
      convert_print((char const   *)b->element_name, verbatim);
      }
    } else {
      {
#line 244
      tmp___23 = get_bothtypes(b, 1);
      }
#line 244
      if (! tmp___23) {
        {
#line 247
        tmp___13 = strcasecmp("command", (char const   *)b->element_name);
        }
#line 247
        if (tmp___13) {
          {
#line 247
          tmp___14 = strcasecmp("filename", (char const   *)b->element_name);
          }
#line 247
          if (tmp___14) {
            {
#line 247
            tmp___15 = strcasecmp("keysym", (char const   *)b->element_name);
            }
#line 247
            if (tmp___15) {
              {
#line 247
              tmp___16 = strcasecmp("keycombo", (char const   *)b->element_name);
              }
#line 247
              if (tmp___16) {
                {
#line 247
                tmp___17 = strcasecmp("otheraddr", (char const   *)b->element_name);
                }
#line 247
                if (tmp___17) {
                  {
#line 247
                  tmp___18 = strcasecmp("function", (char const   *)b->element_name);
                  }
#line 247
                  if (tmp___18) {
                    {
#line 247
                    tmp___19 = strcasecmp("prompt", (char const   *)b->element_name);
                    }
#line 247
                    if (tmp___19) {
                      {
#line 247
                      tmp___20 = strcasecmp("type", (char const   *)b->element_name);
                      }
#line 247
                      if (tmp___20) {
                        {
#line 247
                        tmp___21 = strcasecmp("productname", (char const   *)b->element_name);
                        }
#line 247
                        if (tmp___21) {
                          {
#line 247
                          tmp___22 = strcasecmp("address", (char const   *)b->element_name);
                          }
#line 247
                          if (tmp___22) {
                            {
#line 262
                            tmp___10 = strcasecmp("option", (char const   *)b->element_name);
                            }
#line 262
                            if (tmp___10) {
                              {
#line 262
                              tmp___11 = strcasecmp("parameter", (char const   *)b->element_name);
                              }
#line 262
                              if (tmp___11) {
                                {
#line 262
                                tmp___12 = strcasecmp("replaceable", (char const   *)b->element_name);
                                }
#line 262
                                if (tmp___12) {
                                  {
#line 270
                                  tmp___9 = strcasecmp("emphasis", (char const   *)b->element_name);
                                  }
#line 270
                                  if (tmp___9) {
                                    {
#line 277
                                    tmp___8 = strcasecmp("quote", (char const   *)b->element_name);
                                    }
#line 277
                                    if (tmp___8) {
                                      {
#line 283
                                      tmp___7 = strcasecmp("footnote", (char const   *)b->element_name);
                                      }
#line 283
                                      if (tmp___7) {
                                        {
#line 289
                                        tmp___6 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                                        }
#line 289
                                        if (tmp___6) {
                                          {
#line 293
                                          tmp___4 = strcasecmp("xref", (char const   *)b->element_name);
                                          }
#line 293
                                          if (tmp___4) {
                                            {
#line 293
                                            tmp___5 = strcasecmp("link", (char const   *)b->element_name);
                                            }
#line 293
                                            if (tmp___5) {
                                              {
#line 300
                                              tmp___2 = strcasecmp("ulink", (char const   *)b->element_name);
                                              }
#line 300
                                              if (tmp___2) {
                                                {
#line 300
                                                tmp___3 = strcasecmp("email", (char const   *)b->element_name);
                                                }
#line 300
                                                if (tmp___3) {
                                                  {
#line 308
                                                  tmp___1 = strcasecmp("table", (char const   *)b->element_name);
                                                  }
#line 308
                                                  if (tmp___1) {
                                                    {
#line 314
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"Unknown tag: %s\n",
                                                            b->element_name);
#line 315
                                                    dxml_dump_element(b);
                                                    }
                                                  } else {
                                                    {
#line 310
                                                    get_table(b);
                                                    }
                                                  }
                                                } else {
                                                  {
#line 303
                                                  get_paratype(b->child, verbatim);
#line 304
                                                  printf((char const   */* __restrict  */)"({\\tt ");
#line 305
                                                  tmp___0 = getatrstring(b, "url");
#line 305
                                                  convert_print(tmp___0, verbatim);
#line 306
                                                  printf((char const   */* __restrict  */)"})");
                                                  }
                                                }
                                              } else {
                                                {
#line 303
                                                get_paratype(b->child, verbatim);
#line 304
                                                printf((char const   */* __restrict  */)"({\\tt ");
#line 305
                                                tmp___0 = getatrstring(b, "url");
#line 305
                                                convert_print(tmp___0, verbatim);
#line 306
                                                printf((char const   */* __restrict  */)"})");
                                                }
                                              }
                                            } else {
                                              {
#line 296
                                              tmp = getatrstring(b, "linkend");
#line 296
                                              printf((char const   */* __restrict  */)"\\ref{%s}",
                                                     tmp);
#line 298
                                              get_paratype(b->child, verbatim);
                                              }
                                            }
                                          } else {
                                            {
#line 296
                                            tmp = getatrstring(b, "linkend");
#line 296
                                            printf((char const   */* __restrict  */)"\\ref{%s}",
                                                   tmp);
#line 298
                                            get_paratype(b->child, verbatim);
                                            }
                                          }
                                        } else {
                                          {
#line 291
                                          get_itemizedlist(b->child);
                                          }
                                        }
                                      } else {
                                        {
#line 285
                                        printf((char const   */* __restrict  */)"\\footnote{");
#line 286
                                        get_bookchapter(b->child, 0);
#line 287
                                        printf((char const   */* __restrict  */)"} ");
                                        }
                                      }
                                    } else {
                                      {
#line 279
                                      printf((char const   */* __restrict  */)" ``");
#line 280
                                      get_paratype(b->child, verbatim);
#line 281
                                      printf((char const   */* __restrict  */)"\'\' ");
                                      }
                                    }
                                  } else {
                                    {
#line 273
                                    printf((char const   */* __restrict  */)"{\\b ");
#line 274
                                    get_paratype(b->child, verbatim);
#line 275
                                    printf((char const   */* __restrict  */)"} ");
                                    }
                                  }
                                } else {
                                  {
#line 266
                                  printf((char const   */* __restrict  */)"{\\it ");
#line 267
                                  get_paratype(b->child, verbatim);
#line 268
                                  printf((char const   */* __restrict  */)"} ");
                                  }
                                }
                              } else {
                                {
#line 266
                                printf((char const   */* __restrict  */)"{\\it ");
#line 267
                                get_paratype(b->child, verbatim);
#line 268
                                printf((char const   */* __restrict  */)"} ");
                                }
                              }
                            } else {
                              {
#line 266
                              printf((char const   */* __restrict  */)"{\\it ");
#line 267
                              get_paratype(b->child, verbatim);
#line 268
                              printf((char const   */* __restrict  */)"} ");
                              }
                            }
                          } else {
                            {
#line 258
                            printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                            get_paratype(b->child, verbatim);
#line 260
                            printf((char const   */* __restrict  */)"} ");
                            }
                          }
                        } else {
                          {
#line 258
                          printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                          get_paratype(b->child, verbatim);
#line 260
                          printf((char const   */* __restrict  */)"} ");
                          }
                        }
                      } else {
                        {
#line 258
                        printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                        get_paratype(b->child, verbatim);
#line 260
                        printf((char const   */* __restrict  */)"} ");
                        }
                      }
                    } else {
                      {
#line 258
                      printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                      get_paratype(b->child, verbatim);
#line 260
                      printf((char const   */* __restrict  */)"} ");
                      }
                    }
                  } else {
                    {
#line 258
                    printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                    get_paratype(b->child, verbatim);
#line 260
                    printf((char const   */* __restrict  */)"} ");
                    }
                  }
                } else {
                  {
#line 258
                  printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                  get_paratype(b->child, verbatim);
#line 260
                  printf((char const   */* __restrict  */)"} ");
                  }
                }
              } else {
                {
#line 258
                printf((char const   */* __restrict  */)"{\\tt ");
#line 259
                get_paratype(b->child, verbatim);
#line 260
                printf((char const   */* __restrict  */)"} ");
                }
              }
            } else {
              {
#line 258
              printf((char const   */* __restrict  */)"{\\tt ");
#line 259
              get_paratype(b->child, verbatim);
#line 260
              printf((char const   */* __restrict  */)"} ");
              }
            }
          } else {
            {
#line 258
            printf((char const   */* __restrict  */)"{\\tt ");
#line 259
            get_paratype(b->child, verbatim);
#line 260
            printf((char const   */* __restrict  */)"} ");
            }
          }
        } else {
          {
#line 258
          printf((char const   */* __restrict  */)"{\\tt ");
#line 259
          get_paratype(b->child, verbatim);
#line 260
          printf((char const   */* __restrict  */)"} ");
          }
        }
      }
    }
    }
#line 319
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 321
  return (0);
}
}
#line 327 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bookchapter(dxml_element *b , int paraenter ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;


#line 329
    if (! b) {
#line 329
      goto while_break;
    }
    {

#line 331
    if ((unsigned int )b->element_type != 0U) {
      {
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"element type for b was wrong\n");
#line 334
      exit(1);
      }
    } else {
      {
#line 336
      tmp___9 = strcasecmp("sect1", (char const   *)b->element_name);
      }
#line 336
      if (tmp___9) {
        {
#line 336
        tmp___10 = strcasecmp("section", (char const   *)b->element_name);
        }
#line 336
        if (tmp___10) {
          {
#line 345
          tmp___8 = strcasecmp("sect2", (char const   *)b->element_name);
          }
#line 345
          if (tmp___8) {
            {
#line 353
            tmp___7 = strcasecmp("sect3", (char const   *)b->element_name);
            }
#line 353
            if (tmp___7) {
              {
#line 361
              tmp___6 = strcasecmp("title", (char const   *)b->element_name);
              }
#line 361
              if (tmp___6) {
                {
#line 364
                tmp___5 = get_bothtypes(b, 0);
                }
#line 364
                if (! tmp___5) {
                  {
#line 367
                  tmp___4 = strcasecmp("para", (char const   *)b->element_name);
                  }
#line 367
                  if (tmp___4) {
                    {
#line 373
                    tmp___3 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                    }
#line 373
                    if (tmp___3) {
                      {
#line 377
                      tmp___2 = strcasecmp("table", (char const   *)b->element_name);
                      }
#line 377
                      if (tmp___2) {
                        {
#line 383
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                                b->element_name);
#line 384
                        dxml_dump_element(b->child);
                        }
                      } else {
                        {
#line 379
                        get_table(b);
                        }
                      }
                    } else {
                      {
#line 375
                      get_itemizedlist(b->child);
                      }
                    }
                  } else {
#line 369
                    if (paraenter) {
                      {
#line 369
                      puts("\n\n");
                      }
                    }
                    {
#line 370
                    airac_observe(b, 0);
#line 370
                    get_paratype(b->child, 0);
                    }
#line 371
                    if (paraenter) {
                      {
#line 371
                      puts("\n\n");
                      }
                    }
                  }
                }
              }
            } else {
              {
#line 355
              printf((char const   */* __restrict  */)"\n\\subsubsection{");
#line 356
              tmp___1 = dxml_get_PCDATA_bysimplepath(b->child, "title");
#line 356
              convert_print((char const   *)tmp___1, 0);
#line 357
              printf((char const   */* __restrict  */)"}\n\n");
#line 358
              maybe_label(b);
#line 359
              get_bookchapter(b->child, 1);
              }
            }
          } else {
            {
#line 347
            printf((char const   */* __restrict  */)"\n\\subsection{");
#line 348
            tmp___0 = dxml_get_PCDATA_bysimplepath(b->child, "title");
#line 348
            convert_print((char const   *)tmp___0, 0);
#line 349
            printf((char const   */* __restrict  */)"}\n\n");
#line 350
            maybe_label(b);
#line 351
            get_bookchapter(b->child, 1);
            }
          }
        } else {
          _L: 
          {
#line 339
          printf((char const   */* __restrict  */)"\n\\section{");
#line 340
          tmp = dxml_get_PCDATA_bysimplepath(b->child, "title");
#line 340
          convert_print((char const   *)tmp, 0);
#line 341
          printf((char const   */* __restrict  */)"}\n\n");
#line 342
          maybe_label(b);
#line 343
          get_bookchapter(b->child, 1);
          }
        }
      } else {
#line 336
        goto _L;
      }
    }
    }
#line 387
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 389
  return (0);
}
}
#line 392 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int recursebook(dxml_element *b ) 
{ 
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 395
  tmp = dxml_get_element_byname(b, "chapter");
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;


#line 395
    if (! tmp) {
#line 395
      goto while_break;
    }
    {
#line 397
    printf((char const   */* __restrict  */)"\n\\chapter{");
#line 398
    tmp___0 = dxml_get_PCDATA_bysimplepath(tmp->child, "title");
#line 398
    convert_print((char const   *)tmp___0, 0);
#line 399
    printf((char const   */* __restrict  */)"}\n\n");
#line 400
    maybe_label(tmp);
#line 401
    get_bookchapter(tmp->child, 1);
#line 395
    tmp = tmp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 403
  return (0);
}
}
#line 407 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
int main(int argc , char **argv ) 
{ 
  dxml_element *tmp ;
  int c ;
  char const   *papersize ;
  char const   *articletype ;
  char *title ;
  dxml_element *authorlink ;
  int notfirst ;
  char *tmp___0 ;
  char *tmp___1 ;
  dxml_element *tmp___2 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
#line 412
  papersize = "letter";
#line 413
  articletype = "report";
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 415
    c = getopt(argc, (char * const  *)argv, "p");
    }
#line 415
    if (! (c != -1)) {
#line 415
      goto while_break;
    }
#line 419
    if (c == 112) {
#line 419
      goto case_112;
    }
#line 423
    if (c == 63) {
#line 423
      goto case_63;
    }
#line 425
    goto switch_default;
    case_112: 
#line 420
    articletype = "jreport";
#line 421
    papersize = "a4j";
#line 422
    goto switch_break;
    case_63: 
#line 424
    return (1);
    switch_default: 
    {
#line 426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option -%c used\n",
            c);
    }
#line 427
    return (1);
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 431
  printf((char const   */* __restrict  */)"%s%s\n", "%%Generated by dxml-db2latex",
         "0.8.2.1");
#line 436
  tmp = dxml_read_xml(stdin);
  }
#line 437
  if (tmp) {
    {
#line 439
    title = (char *)((void *)0);
#line 443
    printf((char const   */* __restrict  */)"\\documentclass[%s]{%s}\n\\usepackage{moreverb}\n\\date{}\n\\author{",
           papersize, articletype);
#line 451
    notfirst = 0;
#line 452
    authorlink = dxml_get_element_bysimplepath(tmp, "book/bookinfo/authorgroup/author");
    }
    {
#line 452
    while (1) {
      while_continue___0: /* CIL Label */ ;


#line 452
      if (! authorlink) {
#line 452
        goto while_break___0;
      }
#line 456
      if (notfirst) {
        {
#line 457
        printf((char const   */* __restrict  */)", ");
        }
      } else {
#line 459
        notfirst = 1;
      }
      {
#line 461
      tmp___0 = dxml_get_PCDATA_bysimplepath(authorlink, "author/firstname");
#line 461
      convert_print((char const   *)tmp___0, 0);
#line 462
      printf((char const   */* __restrict  */)" ");
#line 464
      tmp___1 = dxml_get_PCDATA_bysimplepath(authorlink, "author/surname");
#line 464
      convert_print((char const   *)tmp___1, 0);
#line 452
      authorlink = dxml_get_element_byname(authorlink->next, "author");
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: 
    {
#line 468
    printf((char const   */* __restrict  */)"}\n");
#line 471
    printf((char const   */* __restrict  */)"\\title{");
#line 473
    title = dxml_get_PCDATA_bysimplepath(tmp, "book/title");
    }
#line 474
    if (! title) {
      {
#line 475
      title = dxml_get_PCDATA_bysimplepath(tmp, "book/bookinfo/title");
      }
    }
#line 476
    if (title) {
      {
#line 477
      convert_print((char const   *)title, 0);
      }
    }
    {
#line 479
    printf((char const   */* __restrict  */)"}\n\\begin{document}\n\\maketitle\n\\tableofcontents\n");
#line 486
    tmp___2 = dxml_get_element_byname(tmp, "book");
#line 486
    recursebook(tmp___2->child);
#line 487
    printf((char const   */* __restrict  */)"\\end{document}\n");
    }
  } else {
    {
#line 492
    printf((char const   */* __restrict  */)"Something wicked happened!\n");
    }
#line 493
    return (1);
  }
#line 496
  return (0);
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 80 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
dxml_element *dxml_next_notPCDATA(dxml_element *e ) ;
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_next_notPCDATA(dxml_element *e ) 
{ 
  dxml_element *tmp ;

  {
#line 39
  if (! e) {
#line 39
    return ((dxml_element *)((void *)0));
  }
#line 40
  if ((unsigned int )e->element_type == 1U) {
    {
#line 41
    tmp = dxml_next_notPCDATA(e->next);
    }
#line 41
    return (tmp);
  }
#line 42
  return (e);
}
}
#line 45 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_get_element_byname(dxml_element *e , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;


#line 48
    if (! e) {
#line 48
      goto while_break;
    }
    {

    {

#line 50
    if ((unsigned int )e->element_type == 0U) {
      {
#line 50
      tmp = strcmp((char const   *)e->element_name, name);
      }
#line 50
      if (! tmp) {
#line 52
        return (e);
      }
    }
    }
    }
#line 53
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 55
  return ((dxml_element *)((void *)0));
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal(dxml_element *e , char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
#line 79
    return (tmp___1);
  } else {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
#line 82
    return (tmp___2);
  }
}
}
#line 85 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_get_element_bysimplepath(dxml_element *e , char const   *path ) 
{ 
  char *buf ;
  char *tmp ;
  dxml_element *e2 ;

  {
  {
#line 88
  tmp = strdup(path);
#line 88
  buf = tmp;
  }
#line 91
  if (! buf) {
#line 91
    return ((dxml_element *)((void *)0));
  }
  {
#line 92
  e2 = dxml_get_element_bysimplepath_internal(e, buf);
#line 93
  free((void *)buf);
  }
#line 94
  return (e2);
}
}
#line 97 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
char *dxml_get_PCDATA_bysimplepath(dxml_element *e , char const   *path ) 
{ 
  dxml_element *e2 ;
  char *buf ;
  char *tmp ;

  {
  {
#line 104
  tmp = strdup(path);
#line 104
  buf = tmp;
  }
#line 105
  if (! buf) {
#line 105
    return ((char *)((void *)0));
  }
  {
#line 106
  e2 = dxml_get_element_bysimplepath_internal(e, buf);
#line 107
  free((void *)buf);
  }
#line 108
  if (! e2) {
#line 108
    return ((char *)((void *)0));
  }
#line 109
  e2 = e2->child;
#line 109
  if (! e2) {
#line 109
    return ((char *)((void *)0));
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;


    {

#line 110
    if ((unsigned int )e2->element_type != 1U) {
#line 110
      if (! e2) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
    }
#line 112
    e2 = e2->next;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 114
  if (! e2) {
#line 114
    return ((char *)((void *)0));
  }
  {

#line 115
  return (e2->element_name);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space(int i ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;

#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: ;
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute(dxml_attribute *a ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  {

#line 129
  if (a->next) {
    {
#line 130
    recurse_attribute(a->next);
    }
  }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element(dxml_element *e , int level ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {

#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
#line 138
    space(level);
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    {

#line 140
    if (e->element_attribute) {
      {
#line 141
      recurse_attribute(e->element_attribute);
      }
    }
    }
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    {

#line 143
    if (e->child) {
      {
#line 144
      recurse_element(e->child, level + 1);
      }
    }
    }
    {
#line 145
    space(level);
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
  } else {
    {
#line 149
    space(level);
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
  }
  }
  {

  {

#line 152
  if (e->next) {
    {
#line 152
    recurse_element(e->next, level);
    }
  }
  }
  }
#line 153
  return;
}
}
#line 155 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
void dxml_dump_element(dxml_element *e ) 
{ 


  {
  {
#line 158
  recurse_element(e, 0);
  }
#line 159
  return;
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 95 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
void dxml_free_xml(dxml_element *e ) ;
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 71
  tmp = malloc((size_t )l);
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
#line 75
    exit(1);
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars(FILE *f ) 
{ 
  int c ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 92
    c = _IO_getc(f);
    }
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: 
#line 96
    goto switch_break;
    case_neg_1: 
#line 98
    return (1);
    switch_default: 
    {
#line 100
    ungetc(c, f);
    }
#line 101
    return (0);
    switch_break: ;
  }
  while_break: /* CIL Label */ ;
  }


#line 110
  return (0);
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 113
  tmp = _IO_getc(f);
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
    } else {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
#line 133
  tmp = mallocwm((int )sizeof(dxml_element ));
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
#line 153
  tmp = mallocwm(SINGLEBUFSIZ);
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 157
    c = _IO_getc(f);
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
#line 159
    if (tmp___0) {
      {
#line 161
      ungetc(c, f);
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 187
  tmp = initialize_element();
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
#line 189
  tmp___0 = read_character_stream(f, "<>");
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
#line 191
    dxml_free_xml(new_element);
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 208
  tmp = mallocwm((int )sizeof(dxml_attribute ));
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
#line 215
  tmp___1 = skipwhitechars(f);
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
#line 217
  c = _IO_getc(f);
#line 218
  ungetc(c, f);
  }
#line 220
  if (c == 62) {
    {
#line 223
    dxml_free_attrib(new_attribute);
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
#line 223
    dxml_free_attrib(new_attribute);
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
#line 228
  tmp___2 = read_character_stream(f, "> /\t=");
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
#line 230
    dxml_free_attrib(new_attribute);
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
#line 235
  tmp___3 = checkchar('=', f);
  }
#line 235
  if (tmp___3) {
    {
#line 237
    dxml_free_attrib(new_attribute);
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
#line 242
  startquote = _IO_getc(f);
  }
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: 
  {
#line 246
  new_attribute->attribute_data = read_character_stream(f, "\"");
  }
#line 247
  goto switch_break;
  case_39: 
  {
#line 249
  new_attribute->attribute_data = read_character_stream(f, "\'");
  }
#line 250
  goto switch_break;
  switch_default: 
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
#line 253
  exit(1);
  }
  switch_break: 
  {
#line 255
  tmp___4 = checkchar(startquote, f);
  }
#line 255
  if (tmp___4) {
    {
#line 257
    dxml_free_attrib(new_attribute);
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
#line 262
  new_attribute->next = read_attribute(f);
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 278
    c = _IO_getc(f);
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: 
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
#line 284
    return (1);
    case_91: 
    {
#line 287
    while (1) {
      while_continue___0: /* CIL Label */ ;

      {
#line 287
      c = _IO_getc(f);
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }

    while_break___0: ;
#line 290
    goto switch_break;
    case_60: 
#line 294
    if (strict) {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: ;
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: 
  {
#line 305
  tmp = skipwhitechars(f);
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
#line 323
  c = _IO_getc(f);
  }
#line 323
  if (c != 45) {
    {
#line 325
    ungetc(c, f);
#line 326
    tmp = skip_read_PI(f, 0);
    }
#line 326
    return (tmp);
  }
  {
#line 328
  c = _IO_getc(f);
  }
#line 328
  if (c != 45) {
    {
#line 330
    ungetc(c, f);
#line 331
    tmp___0 = skip_read_PI(f, 0);
    }
#line 331
    return (tmp___0);
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 334
    c = _IO_getc(f);
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 342
  tmp___1 = skipwhitechars(f);
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 359
  c = _IO_getc(f);
  }
#line 361
  if (c == 63) {
    {
#line 363
    tmp___1 = skip_read_PI(f, 1);
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
#line 369
    tmp___4 = skip_read_comment(f);
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
#line 373
  ungetc(c, f);
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 393
  tmp = initialize_element();
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
#line 396
  tmp___0 = read_element_start(f);
  }
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: 
  {
#line 399
  free((void *)new_element);
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: 
#line 402
  goto switch_break;
  case_2: 
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: 
  {
#line 410
  tmp___1 = read_character_stream(f, "> /\t");
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
#line 414
  new_element->element_attribute = read_attribute(f);
#line 417
  c = _IO_getc(f);
  }
#line 418
  if (c == -1) {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
#line 427
    tmp___2 = checkchar('>', f);
    }
#line 427
    if (tmp___2) {
      {
#line 429
      free((void *)new_element->element_name);
#line 430
      dxml_free_attrib(new_element->element_attribute);
#line 431
      free((void *)new_element);
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
#line 436
    skipwhitechars(f);
    }
#line 438
    return (new_element);
  }
  {
#line 442
  skipwhitechars(f);
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 445
    c = _IO_getc(f);
    }
#line 446
    if (c == -1) {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
#line 453
      c = _IO_getc(f);
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
#line 456
      ungetc(c, f);
#line 457
      tmp_element = read_element(f);
      }
    } else
#line 459
    if (c == 62) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
#line 463
      exit(1);
      }
    } else {
      {
#line 467
      ungetc(c, f);
#line 468
      tmp_element = read_PCDATA(f);
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }

  while_break: 
  {
#line 490
  buf = read_character_stream(f, "> \t\n\r");
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
#line 491
  if (tmp___5) {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
#line 498
  free((void *)buf);
#line 499
  skipwhitechars(f);
#line 500
  tmp___6 = checkchar('>', f);
  }
#line 500
  if (tmp___6) {
    {
#line 502
    dxml_free_xml(new_element);
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
#line 507
  skipwhitechars(f);
  }
#line 511
  return (new_element);
}
}
#line 520 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
dxml_element *dxml_read_xml(FILE *f ) 
{ 
  dxml_element *e ;
  int c ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 526
    c = _IO_getc(f);
    }
#line 526
    if (! (c != 60)) {
#line 526
      goto while_break;
    }
#line 528
    if (c == -1) {
#line 530
      return ((dxml_element *)((void *)0));
    }
    {
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Garbage is loaded in read_xml prologue\n");
    }
  }
  while_break___1: /* CIL Label */ ;
  }

  while_break: ;
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 538
    e = read_element(f);
    }
#line 538
    if (! ((unsigned long )((void *)0) == (unsigned long )e)) {
#line 538
      goto while_break___0;
    }
    {
#line 540
    skipwhitechars(f);
#line 541
    tmp = checkchar('<', f);
    }
#line 541
    if (tmp) {
#line 544
      return ((dxml_element *)((void *)0));
    }
  }
  while_break___2: /* CIL Label */ ;
  }

  while_break___0: ;
#line 547
  return (e);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib(dxml_attribute *a ) 
{ 
  char *__cil_tmp3 ;

  {
#line 556
  if (! a) {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
#line 563
    free((void *)a->attribute_name);
    }
  }
#line 564
  if (a->attribute_data) {
    {
#line 565
    free((void *)a->attribute_data);
    }
  }
#line 566
  if (a->next) {
    {
#line 567
    dxml_free_attrib(a->next);
    }
  }
  {
#line 568
  free((void *)a);
  }
#line 569
  return;
}
}
#line 571 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
void dxml_free_xml(dxml_element *e ) 
{ 
  char *__cil_tmp3 ;

  {
#line 574
  if (! e) {
    {
#line 576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: e is NULL\n");
    }
#line 577
    return;
  }
#line 580
  if (e->element_name) {
    {
#line 581
    free((void *)e->element_name);
    }
  }
#line 582
  if (e->element_attribute) {
    {
#line 583
    dxml_free_attrib(e->element_attribute);
    }
  }
#line 584
  if (e->child) {
    {
#line 585
    dxml_free_xml(e->child);
    }
  }
#line 586
  if (e->next) {
    {
#line 587
    dxml_free_xml(e->next);
    }
  }
  {
#line 588
  free((void *)e);
  }
#line 589
  return;
}
}
#line 31 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
char const   *get_PCDATA_bysimplepath_i(dxml_element *e , char const   *loc ) 
{ 
  char const   *s ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 33
  tmp = dxml_get_PCDATA_bysimplepath(e, loc);
#line 33
  s = (char const   *)tmp;
  }
#line 34
  if (s) {
#line 35
    return (s);
  } else {
#line 37
    return ("");
  }
}
}
#line 33 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int counter_chapter[5]  = {      0,      0,      0,      0, 
        0};
#line 34 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_chapter  =    (int const   )0;
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect1  =    (int const   )1;
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect2  =    (int const   )2;
#line 37 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect3  =    (int const   )3;
